;; -*- mode: org; eval: (company-mode -1); mode:emmet; -*-
+ Book1: CISSP_ Certified Information Systems Security Professional Study Guide   (2011, John Wiley & Sons) (788 pages)
+ Book2: GSEC GIAC Security Essentials Certification All-in-One Exam Guide (555 pages)
+ Book3: Offensive Security - Offensive Security OSCP-Offensive Security Ltd (2020) (853 pages)
+ Book4: Internet Core Protocols The Definitive Guide Help for Network Administrators by Eric Hall (424 pages)
+ Book5: Linux Administration  A Beginner’s Guide, Wale Soyinka (2016, McGraw-Hill) (802 pages)
+ Book6: Windows Internals 7ed, Part 1, User Mode, (Win 10 and Win Server 2016) by David Solomon, etc. (805 pages)
+ Book7: Windows Internals 6ed, Part 2, Developer Reference, (Win 7 and Win Server 2008 R2) by David Solomon, etc. (594 pages)
================================================================================

* Book3_Chapter 02 the basics
*** the linux filesystem hierachy standard(FHS)
   + /bin - basic programs (ls, cd, cat, etc.)
   + /sbin - system programs (fdisk, mkfs, sysctl, etc)
   + /etc - configuration files
   + /tmp - temporary files (typically deleted on boot)
   + /usr/bin - applications (apt, ncat, nmap, etc.)
   + /usr/share - application support and data files 

*** the man page sections
   + the sections:
     | Section | Contents                                       |
     |---------+------------------------------------------------|
     | 1       | User Commands                                  |
     | 2       | Programming interfaces for kernel system calls |
     | 3       | Programming interfaces to the C library        |
     | 4       | Special files such as device nodes and drivers |
     | 5       | File formats                                   |
     | 6       | Games and amusements such as screen-savers     |
     | 7       | Miscellaneous                                  |
     | 8       | System administration commands                 |

  + Apart from the normal search, ~man -k keywords~: keyword search
     
* Book4_Chapter 01 An Introduction to TCP/IP
  
** a brief history
   + initially devices exchange info through a common communication controller 
     - ~network node -> communication controller -> network node~
   + with TCP/IP, devices could function as a network end-point

*** the internet today
   + Toplevel Internet Service Providers(ISPs)
   + Regional Internet Access Providers(IAPs)
   + End-User Nets

** TCP/IP architecture
   #+begin_quote
   TCP/IP is a collection of of protocols that range from application-specific functions like web
browsing down to the low-level networking protocols like IP and TCP.
   #+end_quote

*** OSI reference model 
    + presentation
      - other detailed transmission utility service that applications may or may not use. e.g., data-compression.
      - since it is better to have a dedicated session layer that purely manage sesions, hence separate the optional services into the presentation layer.
    + session
      - responsible for establishing, and later destroying connections between systems, applications, or users. It may receive the request from any higher layer, and then negotiate a connection using the lower layers. Once a connection is established, the layer simply provides an interface for the higher layers to communicate with.
    + transport
      - may provide reliability services usually lacking from the network layer, for basic transmission services.
    + network
      - identify the addresses of systems on the network, and the actual transmission of data between the systems.
      - must be aware of the physical nature of the network, and package the information in a format that can be further transmitted by the data-link layer.
    + data-link
      - must deal with possible physical layer error, either attempting to retransmit or report the failure to the network layer.  
    + physical
      - strict standards for the wiring systems, specifying e.g., voltage, impedance, etc.

*** TCP/IP basic
    + IP <-> OSI-network-layer
    + TCP or UDP <-> OSI-transport-layer, manage connections.
      - the session management is handled by TCP in browsing.
      - TCP/IP does not provide a formal presentation layer service(e.g. data compression) that an application *must* use, but do provide a few presentation layer service(IBM's NetBIOS, Sun's XDR) that an application *may* use.
    + ? data-link layer
      - data-link protocols are specific to wire, e.g. voltage, 
      - Media Access Control(MAC)
      - Data-Link Connection Identifier(DLCI)
        
**** Data-Link Services
     + implemented by each physical network, the implemetation might different depending on the physical medium. IP datagram is translated to a format that can be understand and delivered in the physical layer.
       
**** the Internet
     + on each local network, data-link or physical level:
       #+begin_quote
       When an IP-enabled device wants to send data to another IP node, the data-link services on that device convert the IP datagrams into a format usable by the local network medium, and then send the data to the destination system using the addressing and framing mechanisms *dictated by the network*.
       #+end_quote
     + Also, IP assume data packets are unreliable and would get lost.

**** the address resolution protocol(ARP)
     + two IP devices must locate each other's hardware addresses before any data exchange. An protocol applicapable to all physical network topology is needed.
     + ARP(who is .40?) -> Response with Hardware Address(I am .40)
      
**** the Internet Control Message Protocol(ICMP)
     + ICMP relies on IP, deliver control message backward.
     + ICMP error message are only sent when there is a detectable problem that is preventing certain packets or datagrams from being delivere due to a specific reason. It indicates that the esnding host should probably stop trying to sent those kinds of datagrams to this specific destination system, or that a different path should be used. 

**** IP datagrams vs. IP packets
     + IP datagram is a more abstract concept, while packets are what been sent in data-link layer:
       #+begin_quote
       IP datagrams get sent as IP packets, which are used to relay the IP data- grams to the destination system, one hop at a time. Although in many cases an IP datagram and an IP packet will be exactly the same, they are conceptually different entities.
       IP datagrams contain whatever data is being sent (and the associated IP headers), while IP packets are used to get the datagram to the destination system (as specified in the IP headers).
       #+end_quote

     + i.e., say: src -> router -> dst, then: src send datagrams to dst, while src send packets to router, in those packets contains datagrams.
       #+begin_quote
       These IP packets are sent using the framing mechanisms defined for the specific network medium in use on the local network, and are sub-ject to network events such as fragmentation or loss. However, the datagram itself will always remain as the original piece of data that was sent by the original sender, regardless of anything that happens to any of the packets that are used to
relay the datagram.
       #+end_quote
     + for example, a 4kb datagram being sent might be too big to fit in a simple frame for transmition in a dial-up access network, hence, the datagram might be split into four IP packets, each of which are sent as individual entities in individual frames. Then on the destination system, once all of the IP packets are received, into the original datagram they will be reassembled and processed.

**** ? nested package and header structure
     + wireshark, 
     + how is segment marked in data-link layer
     + header + data, in each layer.
       
**** ? local loopback network 
     
**** ? routing table, specify router for each destination network.
     + popular protocol popular for private networks
       - Routing Information Protocal(RIP)
       - Open Shrortest Path First(OSPF)
     + those dynamic routing protocols tends to consume a lot of CPU cycles, hence are often ran on routers instead of the host
       - set destination 0.0.0.0 <= default router(e.g., 192.168.100.100), on system boot using protocol such as BOOTP or DHCP, or protocol called Router Discorery 
          
**** ? Route aggregation Q: super route, how to separate local vs internet
     + the routing table method cost lots of resources, is not applicable to Internet.
     + address assignment scheme, separate by physical location, leave routing to ISP, only a few(50,000 routes) super-routes need to be suggested. 

**** datagram independence
     + IP networks treat every individual IP datagram as an independent entity, which means they might take whatever path that the router deems fit when forwarding the datagram.

**** datagram/packet intergrity
     + a *packet* will always be inspected when it arrives a system(including a router) along the delivery path. If corruption or any transient errors is detected, the packet will be destroyed immediately. If a semi-permanent problem, e.g., no rounting table entry for the next destination network is found, is dectected, the IP may also use the Internet Control Message Protocol(ICMP) to return the error message back to the original sender.
     + ? header checksum: Q: on each packet or each datagram?

**** header checksums(the checksum *for the IP header* in the IP header)
     + in every package header, for the header itself, not for the body
     #+begin_quote
     Every device that receives an IP datagram must examine the IP header and compare that information with the value stored in the header's checksum field.
     The data portion ... is not verified, for three reasons:
     #+end_quote
       1. for efficiency.
       2. the data portion always consists of a higher-level datagram, e.g., TCP/UDP. Since those portocol might also provide error-checking routines, the data portions might be examed later anyway.
       3. not all but some high level applications might be able to work with corrupted data, discard those then might be disservice
          
**** time-to-live
     + the time-to-live field in the IP header.
       #+begin_quote
       Every system that forwards the packet decreases the value of the Time-to-Live field by one, before sending the datagram on. If the Time-To-Live value reaches zero before the datagram gets to its final destination, then the gacket is destroyed.
       The purpose of the Time-to-Live field is to keep datagrams that are caught in an undeliverable loop from tying up network resources. ... This safeguard prevents routing loops from causing network meltdowns.
       ...
       The strict definition of the Time-to-Live field states that the value is a measure of time in seconds, or any forwarding act that took less than one second to perform. However, there are very few Internet routers that require a full second to perform forwarding, so this definition is somewhat misrepresentative. In actual practice, the Time-to-Live value is decremented for every hop, regardless of the actual time required to forward a datagram from one network segment to another.
       #+end_quote
       
     + the default
       #+begin_quote
       The default value for the Time-to-Live field should be set to 64 according to the Assigned Numbers registry([[http://www.iana.org/][IANA]]). In addition, some of the higher-layer protocols also have default Time-to-Live values that they are supposed to use(e.g., 64 for TCP, and 1 for IGMP). These values are really only suggestions, ... .
       #+end_quote
       
**** fragmentation and reassembly
     + Maximum Transmission Unit(MTU): the maximum bytes in a single frame.
       #+begin_quote
       Ethernet can pass only 1500 bytes in a single frame, while the typical MTU for 16-Mb/s Token Ring is 17,914 bytes per frame.
       RFC 791 specifies that the maximum allowed MTU size is 65,535 bytes, and that the minimum allowed MTU size is 68 bytes. 
       #+end_quote
     + if datagram > maximum 8 byte alignment to MTU, need to be fragmentated. For example, a 4464-byte datagram(20 bytes header + 4444 bytes data) senting to a network where MTU = 1500, will be fragmented to (20 bytes header + 1480 data)*3 + (20 bytes header + 4 bytes data)*1.
     + in the header:
       - 16-bit Fragment Identifier(like a very short uuid), same for all fragments of a datagram.
       - the Fragmentation Offset, counting by the No.s of 8 bytes blocks.
       - 3-bit Flags field: Reserved(must be marked 0), (the packet) May be further Fragmented Flag(0 if possible), More Fragments(0 if no more)
     + the IP software find the first packet whose fragment offset field is 0, and find the last packet whose More Fragments flag is 0, and assemble the rest in order, once all of the segments arrives.
       
**** prioritization and service-based routing
     + 8-bit type of service(TOS) field, or the TOS byte
       - 3-bit(0-7) precedence field marking prioritization (8 levels of prioritization)
         | Precedence | Definition           |
         |------------+----------------------|
         |          0 | Routine(normal)      |
         |          1 | Priority             |
         |          2 | Immediate            |
         |          3 | Flash                |
         |          4 | Flash Override       |
         |          5 | Critical             |
         |          6 | Internetwork Control |
         |          7 | Network Control      |

       - 4-bit(0-15) the Type-of-Service value predefined by IANA, in RFC 1349.
         | Value | Service               |                        |
         |-------+-----------------------+------------------------|
         |     0 | Normal                | all flags off          |
         |     1 | Minimize Cost         |                        |
         |     2 | Maximize Realiability |                        |
         |     4 | Maximize Throughput   | 1 for high throughput  |
         |     8 | Minimize Delay        | 1 for low delay        |
         |    15 | Maximize Security     | RFC 1455, experimental |

       - the IANA also published suggested TOS values for common application protocols.
         
     + there values are more respected in unix/linux environment.

     + in conjunction with TOS-aware router, it is possible to provide deterministic routing service across the managed network, provide different routing depending on the needs of each packet.

*** the IP Header
    #+begin_quote
    An IP datagram is made up of at least thirteen fields, with twelve fields being used for the IP header, and one field being used for data. In addition, there are also a variety of supplemental fields that may show up as “options” in the header. The total size of the datagram will vary according to the size of the data and the options in use.
    #+end_quote

**** the mandatory fields
     | Field                  |   Bits | Notes                                                         |
     |------------------------+--------+---------------------------------------------------------------|
     | Version                |      4 | IPv4/v6                                                       |
     | Header Length          |      4 | in 32-bit multiples, 20 bytes = 5 * 32/8bits                  |
     | ToS Flags              |      8 | type of service flags                                         |
     | Total Packet Length    |     16 | length of (header + body), in bytes                           |
     | Fragment Identifier    |     16 | Identifier of a datagram                                      |
     | Fragmentation Offset   |     13 | in 8 bytes, the start position of this fragment               |
     | Time-to-Live           |      8 | the remaining hops a datagram can take                        |
     | Protocol Identifier    |      8 | Identifies the higher-layer protocol used in the data section |
     | Header Checksum        |     16 | checksum of the IP header                                     |
     | Source IP Address      |     32 | the 32-bit IP address of the original sender                  |
     | Destination IP Address |     32 | the 32-bit IP address of the final destination                |
     | Options(optional)      | varies | cache specific data if ToC Source Routing or Timestamp, etc.  |
     | Padding(if required)   | varies | an IP datagram header must be a multiple of 32 bits long.     |
     | Data                   | varies | Normally could contain a complete TCP/UDP message,            |
     |                        |        | although it could also be a fragment of another IP datagram.  |

     + header length: used to determine where the data portion start. minum value: 5.
     + [[http://www.isi.edu/in-notes/iana/assignments/protocol-numbers][protocol identifier]]
       | Protocol ID | Protocol Type                            |
       |-------------+------------------------------------------|
       |           1 | Internet Control Message Protocol(ICMP)  |
       |           2 | Internet Group Management Protocol(IGMP) |
       |           6 | Transmission Control Protocol(TCP)       |
       |          17 | User Datagram Protocol(UDP)              |
     + header checksum: must be modified every time the packet forwarded across a router(since at least TTL will change)
     + ip options: 
       #+begin_quote
       Options are not mandatory, and most IP datagrams do not have any options defined. However, all network devices should support the use of options. If a device does not recognize a specific option type, then it should ignore the option and go ahead and process the datagram as normal.
       ...
       There can be many options in a single IP datagram, up to the amount of free space available in the IP header. Since an IP header can only be 60 bytes long at most—and since 20 bytes are already in use by the default fields—only 40 bytes are available for options.
       #+end_quote
       - option-type (8 bits) [[http://www.isi.edu/in-notes/iana/assignments/ip-parameters][most commonly used ip option types (IANA)]]
         + copy(1 bit): should be copy to every fragment's header.
         + class(2 bits): 0 for network control options, 2 for debugging services, 1 & 3 reserved for future use.
         + type(5 bits): specify which ip option
       - option-length (8 bits)
       - option-data (varies)
         
*** IP in Action, basic routing table
    |    Destination |         Netmask |       Gateway |     Interface |
    |----------------+-----------------+---------------+---------------|
    |        0.0.0.0 |         0.0.0.0 |  192.168.10.3 | 192.168.10.10 |
    |      127.0.0.0 |       255.0.0.0 |     127.0.0.1 |     127.0.0.1 |
    |   192.168.10.0 |   255.255.255.0 | 192.168.10.10 | 192.168.10.10 |
    | 192.168.10.255 | 255.255.255.255 | 192.168.10.10 | 192.168.10.10 | 
    |                |                 |               |               |
    
    + 0.0.0.0 the default route for this device 
    + 192.168.10.255 broadcast address for the local network
    + in each network the device should have an unique ip address(assigned to the interface): in this case, the system is connected to a loopback network(this machine) and a local Ethernet network.
    + 127.0.0.0 vs 127.0.0.1:
      #+begin_quote
      the 127.0.0.0 is a network address. Together with mask 255.0.0.0 it gives you a hint that ... 127.*.*.* will contain loopback addresses.
      the 127.0.0.1 is a loopback address, so does 127.0.0.2 or 127.0.0.3 and etc.
      #+end_quote
      
**** subnet mask and multicast address
    + 172.16.0.0/12:
      | Note |                            Binary form |    Dot-decimal |
      |------+----------------------------------------+----------------|
      |    1 | 10101100.0001 *0000.00000000.00000000* |     172.16.0.0 |
      |    2 |    11111111.11110000.00000000.00000000 |    255.240.0.0 |
      |    3 |    00000000.00001111.11111111.11111111 |   0.15.255.255 |
      |    4 |    10101100.00011111.11111111.11111111 | 172.31.255.255 |

      1. the ip address
      2. Subnet Mask
      3. Bit Complement(Bitwise NOT) of the Subnet Mask
      4. Broadcast address(Bitwise OR of 1 and 3)
         
    + special case:
      #+begin_quote
      255.255.255.255 is the broadcast address of the zero network or 0.0.0.0, which in Internet Protocol stands for *this network*, i.e. the local network. Transmission to this address is limited by definition, in that it is never forwarded by the routers connecting the local network to other networks.
      #+end_quote

**** possible routing problem and debugging
    1. the pinciple: 
      - ip devices try to connect each other directly whenever possible, and use route when direct connection is not possible.
      #+begin_quote
      Since IP is designed as a node-centric networking protocol, every device has equal access to the network. In this model, any device can communicate with any other device directly, without requiring the services of a centralized host. Nodes do not send traffic to a central host for processing and relay services, but instead communicate directly with the destination system, if possible.

      When this is not possible—such as when the two hosts are on separate networks—then the sending device has to locate another device to relay the traffic to the destination system on its behalf. Even in this situation the sending device is still self-deterministic, since it chooses which local device it will send the datagrams to for forwarding.

      The process of choosing an intermediate forwarding device is called routing. Whenever a device needs to choose a forwarder, it looks at a local list of available networks and forwarders (called the “routing table”), and decides which interface and forwarder is the most appropriate for the specific datagram that needs to be sent.
      #+end_quote

      - fragmentation problem might be detected by sending large size ICMP datagram using ping.
     
      - use the ICMP protocol to debug, since almost all problems are related with delivery difficulties.
        #+begin_quote
        Since IP provides only simple delivery services, almost all of the problems with IP are related to delivery difficulties. Perhaps a network segment is down, or a router has been misconfigured, or a host is no longer accepting packets.

        In order to effectively debug problems with IP delivery, you should rely on the ICMP protocol. It is the function of ICMP to report on problems that will keep IP datagrams from getting delivered to their destination effectively. 
        #+end_quote
    2. routing table misconfigured
       - traceroute
    3. media related issues
       - possible infractructure problem
       #+begin_quote
       Since IP packets are sent inside of media-specific frames, there can be problems with some network media that will manifest when used with IP packets. For example, some network managers have reported problems with network infrastructure equipment such as Ethernet hubs and switches that have problems dealing with full-sized (1500-byte) packets. In those situations, you will need to use ICMP to probe the network for delivery problems through equipment that is acting suspicious.
       #+end_quote
  
**** ?Q: ARP and peers on an VPN
     + ?(lack reference)dial-up vs VPN:
       - dial-up use telephone line, but I think they share a similar topology(packet switching), i.e. client-server-Internet
       - while all IP devices are treated as independence entities, both dial-up and VPN delegate ip communication with the Internet to a "server".

     + ?(lack reference)peers on VPN
       - if any communication between clients may happen, it should be after they dial in to the VPN server.
       - so potential arp attack might happen only if the clients are sharing an environment which is behind the VPN server(a shared lab, for example.) A client may send ARP through a shared lab machine. (detail?)
       - ? other angle on the VPN server?


* Book4_Chapter 03 The Address Resolution Protocol
  #+begin_quote
  In order for IP systems to communicate with each other, they must first be able to identify the hardware addresses of the other devices on the same network segment that the local device is on. This service is provided by the Address Resolution Protocol.
  #+end_quote

** the ARP standard
  #+begin_quote
  ARP packets communicate with the data-link layer directly, the same as IP packets. As such, ARP packets are completely separate from IP packets; they even have a different protocol ID of 0806, instead of 0800 as used with IP.
  #+end_quote

  + fields of an ARP packet
| field No. | field detail                                                    |
|-----------+-----------------------------------------------------------------|
| 1         | the hardware address of the sources(who issued the ARP request) |
| 2         | the IP address of the source                                    |
| 3         | the hardware address of the destination                         |
| 4         | the IP address of the destination                               |
| 5         | the "message type" of this ARP packet                           |

  + a normal packet of ARP request :
  | field No. | field detail                         |
  |-----------+--------------------------------------|
  | 1         | the hardware address of the "sender" |
  | 2         | the IP address of the "sender"       |
  | 3         | 000...0                              |
  | 4         | the IP address of the "target"       |
  | 5         | "ARP request"                        |

  + a normal packet of ARP response:
| field No. | field detail                         |
|-----------+--------------------------------------|
| 1         | the hardware address of the "sender" |
| 2         | the IP address of the "sender"       |
| 3         | the hardware address of the "target" |
| 4         | the IP address of the "target"       |
| 5         | "ARP request"                        |
    
 + since ARP has no timeout, in some implementations when a new packet come to the queue and ask for an ARP request for an IP address, whose last ARP request is yet to be received, then the former packet which required the last ARP request may be dropped, depend on the implementation.
   #+begin_quote
   Many implementations only have room in the ARP lookup queue for a single packet for each of the hosts being queried. If an ARP request is not satisfied and another packet arrives from IP for the host being queried, then the first query will likely be aborted, and a second query will be issued. 
   #+end_quote

*** the ARP Cache
   #+begin_quote
   When the requesting system gets an ARP response, it will store the hardware and IP address pair of the requested device into a local cache. The next time that system needs to send data, it will check the local cache, and if an entry is found it will go ahead and use it, eliminating the need to broadcast another request.

   Likewise, the system that responded to the ARP broadcast will store the hardware and IP addresses of the system that sent the original broadcast. If it did not do so, it would have to issue an ARP broadcast to find out where to send the ARP response.

   Since all of the systems on the network will see the ARP broadcast, they could go ahead and capture the IP and hardware addresses of the sender, storing this information in their own caches. However, doing this might cause existing entries in the cache to be flushed (an especially problematic issue with systems that have small caches), so *only those systems who already have the sender’s IP address in their cache should update their entries*. Hosts that do not already have the device in their cache should ignore the broadcast.
   #+end_quote

   + potential issues:
     - cache size issue
     - cache timeout issue: If lifespan too long, old cache still in effect on some host, so that package of newly assigned ip went wrongly to old machines; Else, lifespan too short, the network is flooded with ARP broadcast.
     #+begin_quote
     RFC826: (Did not suggest a specific timeout value, but do state that) if a device sees an ARP packet whose IP address is already in the cache, then any timeout clocks for that entry should be reset. This helps the already-cached data to survive for as long as possible.
     #+end_quote
     - static caching
*** Proxy ARP p102