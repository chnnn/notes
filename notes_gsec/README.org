;; -*- mode: org; eval: (company-mode -1); mode:emmet; -*-
+ Book1: CISSP_ Certified Information Systems Security Professional Study Guide   (2011, John Wiley & Sons) (788 pages)
+ Book2: GSEC GIAC Security Essentials Certification All-in-One Exam Guide (555 pages)
+ Book3: Offensive Security - Offensive Security OSCP-Offensive Security Ltd (2020) (853 pages)
+ Book4: Internet Core Protocols The Definitive Guide Help for Network Administrators by Eric Hall (424 pages)
+ Book5: Linux Administration  A Beginner’s Guide, Wale Soyinka (2016, McGraw-Hill) (802 pages)
+ Book6: Windows Internals 7ed, Part 1, User Mode, (Win 10 and Win Server 2016) by David Solomon, etc. (805 pages)
+ Book7: Windows Internals 6ed, Part 2, Developer Reference, (Win 7 and Win Server 2008 R2) by David Solomon, etc. (594 pages)
================================================================================

* Book4_Chapter 01 An Introduction to TCP/IP
  
** a brief history
   + initially devices exchange info through a common communication controller 
     - ~network node -> communication controller -> network node~
   + with TCP/IP, devices could function as a network end-point

*** the internet today
   + Toplevel Internet Service Providers(ISPs)
   + Regional Internet Access Providers(IAPs)
   + End-User Nets

** TCP/IP architecture
   #+begin_quote
   TCP/IP is a collection of of protocols that range from application-specific functions like web
browsing down to the low-level networking protocols like IP and TCP.
   #+end_quote

*** OSI reference model 
    + presentation
      - other detailed transmission utility service that applications may or may not use. e.g., data-compression.
      - since it is better to have a dedicated session layer that purely manage sesions, hence separate the optional services into the presentation layer.
    + session
      - responsible for establishing, and later destroying connections between systems, applications, or users. It may receive the request from any higher layer, and then negotiate a connection using the lower layers. Once a connection is established, the layer simply provides an interface for the higher layers to communicate with.
    + transport
      - may provide reliability services usually lacking from the network layer, for basic transmission services.
    + network
      - identify the addresses of systems on the network, and the actual transmission of data between the systems.
      - must be aware of the physical nature of the network, and package the information in a format that can be further transmitted by the data-link layer.
    + data-link
      - must deal with possible physical layer error, either attempting to retransmit or report the failure to the network layer.  
    + physical
      - strict standards for the wiring systems, specifying e.g., voltage, impedance, etc.

*** TCP/IP basic
    + IP <-> OSI-network-layer
    + TCP or UDP <-> OSI-transport-layer, manage connections.
      - the session management is handled by TCP in browsing.
      - TCP/IP does not provide a formal presentation layer service(e.g. data compression) that an application *must* use, but do provide a few presentation layer service(IBM's NetBIOS, Sun's XDR) that an application *may* use.
    + ? data-link layer
      - data-link protocols are specific to wire, e.g. voltage, 
      - Media Access Control(MAC)
      - Data-Link Connection Identifier(DLCI)
        
**** Data-Link Services
     + implemented by each physical network, the implemetation might different depending on the physical medium. IP datagram is translated to a format that can be understand and delivered in the physical layer.
       
**** the Internet
     + on each local network, data-link or physical level:
       #+begin_quote
       When an IP-enabled device wants to send data to another IP node, the data-link services on that device convert the IP datagrams into a format usable by the local network medium, and then send the data to the destination system using the addressing and framing mechanisms *dictated by the network*.
       #+end_quote
     + Also, IP assume data packets are unreliable and would get lost.

**** the address resolution protocol(ARP)
     + two IP devices must locate each other's hardware addresses before any data exchange. An protocol applicapable to all physical network topology is needed.
     + ARP(who is .40?) -> Response with Hardware Address(I am .40)
      
**** the Internet Control Message Protocol(ICMP)
     + ICMP relies on IP, deliver control message backward.
     + ICMP error message are only sent when there is a detectable problem that is preventing certain packets or datagrams from being delivere due to a specific reason. It indicates that the esnding host should probably stop trying to sent those kinds of datagrams to this specific destination system, or that a different path should be used. 

**** IP datagrams vs. IP packets
     + IP datagram is a more abstract concept, while packets are what been sent in data-link layer:
       #+begin_quote
       IP datagrams get sent as IP packets, which are used to relay the IP data- grams to the destination system, one hop at a time. Although in many cases an IP datagram and an IP packet will be exactly the same, they are conceptually different entities.
       IP datagrams contain whatever data is being sent (and the associated IP headers), while IP packets are used to get the datagram to the destination system (as specified in the IP headers).
       #+end_quote

     + i.e., say: src -> router -> dst, then: src send datagrams to dst, while src send packets to router, in those packets contains datagrams.
       #+begin_quote
       These IP packets are sent using the framing mechanisms defined for the specific network medium in use on the local network, and are sub-ject to network events such as fragmentation or loss. However, the datagram itself will always remain as the original piece of data that was sent by the original sender, regardless of anything that happens to any of the packets that are used to
relay the datagram.
       #+end_quote
     + for example, a 4kb datagram being sent might be too big to fit in a simple frame for transmition in a dial-up access network, hence, the datagram might be split into four IP packets, each of which are sent as individual entities in individual frames. Then on the destination system, once all of the IP packets are received, into the original datagram they will be reassembled and processed.

**** ? nested package and header structure
     + wireshark, 
     + how is segment marked in data-link layer
     + header + data, in each layer.
       
**** ? local loopback network 
     
**** ? routing table, specify router for each destination network.
     + popular protocol popular for private networks
       - Routing Information Protocal(RIP)
       - Open Shrortest Path First(OSPF)
     + those dynamic routing protocols tends to consume a lot of CPU cycles, hence are often ran on routers instead of the host
       - set destination 0.0.0.0 <= default router(e.g., 192.168.100.100), on system boot using protocol such as BOOTP or DHCP, or protocol called Router Discorery 
          
**** ? Route aggregation Q: super route, how to separate local vs internet
     + the routing table method cost lots of resources, is not applicable to Internet.
     + address assignment scheme, separate by physical location, leave routing to ISP, only a few(50,000 routes) super-routes need to be suggested. 

**** datagram independence
     + IP networks treat every individual IP datagram as an independent entity, which means they might take whatever path that the router deems fit when forwarding the datagram.

**** datagram/packet intergrity
     + a *packet* will always be inspected when it arrives a system(including a router) along the delivery path. If corruption or any transient errors is detected, the packet will be destroyed immediately. If a semi-permanent problem, e.g., no rounting table entry for the next destination network is found, is dectected, the IP may also use the Internet Control Message Protocol(ICMP) to return the error message back to the original sender.
     + ? header checksum: Q: on each packet or each datagram?

**** header checksums(the checksum *for the IP header* in the IP header)
     + in every package header, for the header itself, not for the body
     #+begin_quote
     Every device that receives an IP datagram must examine the IP header and compare that information with the value stored in the header's checksum field.
     The data portion ... is not verified, for three reasons:
     #+end_quote
       1. for efficiency.
       2. the data portion always consists of a higher-level datagram, e.g., TCP/UDP. Since those portocol might also provide error-checking routines, the data portions might be examed later anyway.
       3. not all but some high level applications might be able to work with corrupted data, discard those then might be disservice
          
**** time-to-live
     + the time-to-live field in the IP header.
       #+begin_quote
       Every system that forwards the packet decreases the value of the Time-to-Live field by one, before sending the datagram on. If the Time-To-Live value reaches zero before the datagram gets to its final destination, then the gacket is destroyed.
       The purpose of the Time-to-Live field is to keep datagrams that are caught in an undeliverable loop from tying up network resources. ... This safeguard prevents routing loops from causing network meltdowns.
       ...
       The strict definition of the Time-to-Live field states that the value is a measure of time in seconds, or any forwarding act that took less than one second to perform. However, there are very few Internet routers that require a full second to perform forwarding, so this definition is somewhat misrepresentative. In actual practice, the Time-to-Live value is decremented for every hop, regardless of the actual time required to forward a datagram from one network segment to another.
       #+end_quote
       
     + the default
       #+begin_quote
       The default value for the Time-to-Live field should be set to 64 according to the Assigned Numbers registry([[http://www.iana.org/][IANA]]). In addition, some of the higher-layer protocols also have default Time-to-Live values that they are supposed to use(e.g., 64 for TCP, and 1 for IGMP). These values are really only suggestions, ... .
       #+end_quote
       
**** fragmentation and reassembly
     + Maximum Transmission Unit(MTU): the maximum bytes in a single frame.
       #+begin_quote
       Ethernet can pass only 1500 bytes in a single frame, while the typical MTU for 16-Mb/s Token Ring is 17,914 bytes per frame.
       RFC 791 specifies that the maximum allowed MTU size is 65,535 bytes, and that the minimum allowed MTU size is 68 bytes. 
       #+end_quote
     + if datagram > maximum 8 byte alignment to MTU, need to be fragmentated. For example, a 4464-byte datagram(20 bytes header + 4444 bytes data) senting to a network where MTU = 1500, will be fragmented to (20 bytes header + 1480 data)*3 + (20 bytes header + 4 bytes data)*1.
     + in the header:
       - 16-bit Fragment Identifier(like a very short uuid), same for all fragments of a datagram.
       - the Fragmentation Offset, counting by the No.s of 8 bytes blocks.
       - 3-bit Flags field: Reserved(must be marked 0), (the packet) May be further Fragmented Flag(0 if possible), More Fragments(0 if no more)
     + the IP software find the first packet whose fragment offset field is 0, and find the last packet whose More Fragments flag is 0, and assemble the rest in order, once all of the segments arrives.
       
**** prioritization and service-based routing
     + 8-bit type of service(TOS) field, or the TOS byte
       - 3-bit(0-7) precedence field marking prioritization (8 levels of prioritization)
         | Precedence | Definition           |
         |------------+----------------------|
         |          0 | Routine(normal)      |
         |          1 | Priority             |
         |          2 | Immediate            |
         |          3 | Flash                |
         |          4 | Flash Override       |
         |          5 | Critical             |
         |          6 | Internetwork Control |
         |          7 | Network Control      |

       - 4-bit(0-15) the Type-of-Service value predefined by IANA, in RFC 1349.
         | Value | Service               |                        |
         |-------+-----------------------+------------------------|
         |     0 | Normal                | all flags off          |
         |     1 | Minimize Cost         |                        |
         |     2 | Maximize Realiability |                        |
         |     4 | Maximize Throughput   | 1 for high throughput  |
         |     8 | Minimize Delay        | 1 for low delay        |
         |    15 | Maximize Security     | RFC 1455, experimental |

       - the IANA also published suggested TOS values for common application protocols.
         
     + there values are more respected in unix/linux environment.

     + in conjunction with TOS-aware router, it is possible to provide deterministic routing service across the managed network, provide different routing depending on the needs of each packet.

*** the IP Header
    #+begin_quote
    An IP datagram is made up of at least thirteen fields, with twelve fields being used for the IP header, and one field being used for data. In addition, there are also a variety of supplemental fields that may show up as “options” in the header. The total size of the datagram will vary according to the size of the data and the options in use.
    #+end_quote

**** the mandatory fields
     | Field                  |   Bits | Notes                                                         |
     |------------------------+--------+---------------------------------------------------------------|
     | Version                |      4 | IPv4/v6                                                       |
     | Header Length          |      4 | in 32-bit multiples, 20 bytes = 5 * 32/8bits                  |
     | ToS Flags              |      8 | type of service flags                                         |
     | Total Packet Length    |     16 | length of (header + body), in bytes                           |
     | Fragment Identifier    |     16 | Identifier of a datagram                                      |
     | Fragmentation Offset   |     13 | in 8 bytes, the start position of this fragment               |
     | Time-to-Live           |      8 | the remaining hops a datagram can take                        |
     | Protocol Identifier    |      8 | Identifies the higher-layer protocol used in the data section |
     | Header Checksum        |     16 | checksum of the IP header                                     |
     | Source IP Address      |     32 | the 32-bit IP address of the original sender                  |
     | Destination IP Address |     32 | the 32-bit IP address of the final destination                |
     | Options(optional)      | varies | cache specific data if ToC Source Routing or Timestamp, etc.  |
     | Padding(if required)   | varies | an IP datagram header must be a multiple of 32 bits long.     |
     | Data                   | varies | Normally could contain a complete TCP/UDP message,            |
     |                        |        | although it could also be a fragment of another IP datagram.  |

     + header length: used to determine where the data portion start. minum value: 5.
     + [[http://www.isi.edu/in-notes/iana/assignments/protocol-numbers][protocol identifier]]
       | Protocol ID | Protocol Type                            |
       |-------------+------------------------------------------|
       |           1 | Internet Control Message Protocol(ICMP)  |
       |           2 | Internet Group Management Protocol(IGMP) |
       |           6 | Transmission Control Protocol(TCP)       |
       |          17 | User Datagram Protocol(UDP)              |
     + header checksum: must be modified every time the packet forwarded across a router(since at least TTL will change)
     + ip options: 
       #+begin_quote
       Options are not mandatory, and most IP datagrams do not have any options defined. However, all network devices should support the use of options. If a device does not recognize a specific option type, then it should ignore the option and go ahead and process the datagram as normal.
       ...
       There can be many options in a single IP datagram, up to the amount of free space available in the IP header. Since an IP header can only be 60 bytes long at most—and since 20 bytes are already in use by the default fields—only 40 bytes are available for options.
       #+end_quote
       - option-type (8 bits) [[http://www.isi.edu/in-notes/iana/assignments/ip-parameters][most commonly used ip option types (IANA)]]
         + copy(1 bit): should be copy to every fragment's header.
         + class(2 bits): 0 for network control options, 2 for debugging services, 1 & 3 reserved for future use.
         + type(5 bits): specify which ip option
       - option-length (8 bits)
       - option-data (varies)
         
*** IP in Action, basic routing table
    |    Destination |         Netmask |       Gateway |     Interface |
    |----------------+-----------------+---------------+---------------|
    |        0.0.0.0 |         0.0.0.0 |  192.168.10.3 | 192.168.10.10 |
    |      127.0.0.0 |       255.0.0.0 |     127.0.0.1 |     127.0.0.1 |
    |   192.168.10.0 |   255.255.255.0 | 192.168.10.10 | 192.168.10.10 |
    | 192.168.10.255 | 255.255.255.255 | 192.168.10.10 | 192.168.10.10 | 
    |                |                 |               |               |
    
    + 0.0.0.0 the default route for this device 
    + 192.168.10.255 broadcast address for the local network
    + in each network the device should have an unique ip address(assigned to the interface): in this case, the system is connected to a loopback network(this machine) and a local Ethernet network.
    + 127.0.0.0 vs 127.0.0.1:
      #+begin_quote
      the 127.0.0.0 is a network address. Together with mask 255.0.0.0 it gives you a hint that ... 127.*.*.* will contain loopback addresses.
      the 127.0.0.1 is a loopback address, so does 127.0.0.2 or 127.0.0.3 and etc.
      #+end_quote
      
**** subnet mask and multicast address
    + 172.16.0.0/12:
      | Note |                            Binary form |    Dot-decimal |
      |------+----------------------------------------+----------------|
      |    1 | 10101100.0001 *0000.00000000.00000000* |     172.16.0.0 |
      |    2 |    11111111.11110000.00000000.00000000 |    255.240.0.0 |
      |    3 |    00000000.00001111.11111111.11111111 |   0.15.255.255 |
      |    4 |    10101100.00011111.11111111.11111111 | 172.31.255.255 |

      1. the ip address
      2. Subnet Mask
      3. Bit Complement(Bitwise NOT) of the Subnet Mask
      4. Broadcast address(Bitwise OR of 1 and 3)
         
    + special case:
      #+begin_quote
      255.255.255.255 is the broadcast address of the zero network or 0.0.0.0, which in Internet Protocol stands for *this network*, i.e. the local network. Transmission to this address is limited by definition, in that it is never forwarded by the routers connecting the local network to other networks.
      #+end_quote

**** possible routing problem and debugging

**** ?Q: ARP and peers on an VPN
