* L0 Autumn
** p2
   
*** Q3 プログラミング
**** 1
     1. -0.7
     2. 1 * -0.5 + 0 * -0.5 + 0.7 = 0.2 > 0, ans = 1
    
**** 2
     1. BY
     2. X[out][in]
     3. WY[in]
     4. >0   　　　　　　-> (が) 0より大きい
     5. WM[mid][in]
     6. M[out][mid]
     7. WY[mid]         -> 回答が前4問のテーブルにある可能性あり 
*** Q7 組み込み
**** 1
    1. 60000/350 -> 171.4, even is off, the 171 is on.
    2. バンドフィルタ
       
**** 2
    1. 5
    2. a: ON, b: OFF
       
**** 3
    1. c: ONイベント d: 今回値
    2. *カウント値が0に戻ったとき*
       - どんなとき? -> ...とき
    3. *T[N]に65535を加算する*
       - に...を加算する
         
* Notes - p2:
  + The answer of MCQ questions might not present in the text. i.e. Treated as 'common sense'
** programming  
   + アイウエオカキ 空欄埋めの答えは問題文の中にある。例えば、0より、bias BYを入れる。
  



   
* Misc (L03 応用情報技術者合格教本 2021)
** Logical Operator (p21)
   - not(A * B) = not(A) + not(B)
   - not(A + B) = not(A) * not(B)
     
** Information Content (情報量) (p23)
   - ~I = -log_2 P(J)~ bits, where ~P(J)~ is the possibility that the event happens.
   - less I more accurate. Compare with "Maximum average Information Content"

*** Huffman Tree
    
*** Run Length Encoding(ランレングス符号化)
    - 4A0B5C
    - 12, 10, 2... (12 * 1, 10 * 0, 2 * 1...)
      
*** PCM(Pulse Code Modulation)(パルス符号変調), DPCM, ADPCM (p28)
    + 手順:
      1. 標本化, サンプリング周波数(per seconds)(lossless: use > x2 freq of the original analog signal when sampling)
      2. 量子化, 量子化ビット数(info bits to be outputted per sampling)
      3. 符号化, translate info into bits
         

*** Chomsky Hierarchy:
**** Type-3 Finite state automaton (p29) (Regular Language) (正規文法)
    + accepting state (受理状態)
      
**** Type-2 Non-deterministic Pushdown automaton (Context-free Language)(文脈自由文法)
     + Most programming languages are context-free language.
     + *Backus–Naur Form (BNF記法)*
       - ~<> ::= <> | <>~        # ~::=~ "is", ~|~ "or", ~<>~ "Non-terminals"
       - ~<> ::= 0 | 1 | a | b~  #  the '0', '1', 'a', 'b' are "Terminals"
       - examples:
         + ~<postal-address> ::= <name-part> <street-address> <zip-part>~
         + ~<opt-suffix-part> ::= "Sr." | "Jr." | <roman-numeral> | ""~
           

     
**** Type-1 Linear-bounded non-deterministic Turing machine (Context-sensitive Language) (文脈依存文法)
     
**** Type-0 Turing machine (Recursively enumerable Language)

*** Reverse Polish notation (逆ポーランド記法)
    - traverse the tree bottom-up
    - ~X 2 3 * 4 7 * + 5 - =~
    - X=2*3 + 4*7 -5 -> [X, [[[2,3]*, [4,7]*]+, 5-] ]=
    
      
*** Graph Theory
    
**** Hamiltonian graph
     + a graph that has hamilton circuit. i.e. a path that go through all vertex exactly once.
     
**** bipartite graph (二部グラフ)
     + a bipartite graph (or bigraph) is a graph whose vertices can be divided into two disjoint and independent sets and such that every edge connects a vertex in to one in. (wiki)
       
**** adjacency list(隣接リスト)
     
**** adjacency matrix(隣接行列)
     #+begin_quote
     let M = 
     | 0 | 1 | 1 | 0 |
     | 1 | 0 | 1 | 1 |
     | 1 | 1 | 0 | 1 |
     | 0 | 1 | 1 | 0 |
     => M ^ 2 is:
     | 2 | 1 | 1 | 2 |
     | 1 | 3 | 2 | 1 |
     | 1 | 2 | 3 | 1 |
     | 2 | 1 | 1 | 2 |
     (the number of all existing paths, that go through exactly 1 other vertex, between v_i and v_j)
     (p44)
     #+end_quote
     
**** ダイクストラ法(Dijkstra's algorithm) (p45)
     + let the graph: 
       - A -(5)-> C -(2)-> D
       - A -(3)-> B -(1)-> C
       - A -(3)-> B -(5)-> D
         
     + the algorithm:
       1. 3 < 5 -> the '*' vertex is B
       2. recalculate distance connected to the '*' vertex:
          - 3 + 1 < 5 -> del A-(5)-> C
          - 3 + 5 = 8 -> A -(8)-> D, A -(4)-> C -(2)-> D
       3. 4 < 8 -> the '*' vertex is tC
       4. 6 < 8 -> the shortest path is A -(3)-> B -(1)-> C -(2)-> D
          
     + the algorithm in general:
       1. find the nearest vertex, let it be (*)
       2. (re)calculate the distance to all adjacent vertices of (*), discard the inferior path.
       3. loop till the (*) is the goal
          
*** Statistic

**** Bayes' theorem(ベイズの定理)
     + P(B|A) = ( P(A|B) * P(B) ) / ( P(A) )
       
**** Markov process(マルコフ過程)
     + P ^ 2
       
**** Normal distribution
     + CL [+|-] 3 * sigma = [UCL | LCL] Upper/Lower Control Limit
       
**** Correlation Coefficient
     + r = 1, X and Y are strong positive related
     + r = 0, not related
     + r = -1, strong negative related

**** Partial Coefficient(偏相関係数)
     + r_(yx1 . x2 ), the partial coefficient between Y and X1, without the effect of X2
     
**** Spurious correlation(疑似相関)
     + Wiki: In statistics, a spurious relationship or spurious correlation is a mathematical relationship in which two or more events or variables are associated but not causally related, due to either coincidence or the presence of a certain third, unseen factor.
       
**** logistic regression(ロジスティクス回帰分析)
     
*** Derivative
**** Bisection method(二分法)
**** Newton's method(ニュートン法)
     + special considerations
     + time complexity:
       - ~O(log(N)F(N))~ , for N-digit precision, F(N) as the cost of eval(f(x)/f'(x))
       - For N-digit precision, faster than Bisection method, since in Bisection, the cost of N-digit is ~N * eval(f(x))~, while if *automatic(algorithmic) differentiation* is used, Newton's method gives ~(n+1) * eval(f(x))~ where n is the power of x in f(x).
       - [[http://www.cas.mcmaster.ca/~cs777/presentations/AD.pdf][Computational Complexity of Automatic Differentiation]]
         
**** Numerical Integration(数値積分)
     + Simpson's rule
       
*** Matrix
**** Invertible/Nonsingular matrix(正則行列)
     + a matrix of which the *inverse matrix(逆行列)* exists.
     + ~A(A^-1) = (A^-1)A = E~, where E is the corresponding *identity matrix(単位行列)*. Otherwise the matrix provide less information, hence is called 'degenerated'.
       
**** Augmented Matrix (拡大行列)
     + Gaussian elimination(掃き出し法)
       
*** Machine Learning
    + Supervised learning(教師あり学習)
    + Unsupervised learning(教師なし学習)
    + Reinforcement learning(強化学習)
    + Deep learning
      - Deep Neural Network
      - Convolutinoal neural network

** Algorithm && Programming
*** Tree
    + root : height 0
    + complete binary tree (完全2分木)

**** Self-balancing Binary Search Tree
     + AVL tree. Height difference less than 1 on any node.
     + B tree. Multiple children per node. Less rebalancing, good for File System, DB Indexing
     
       
*** Hashing
    + to prevent synonoym(シノニム)
      - open address (how to delete)
      - chaining
        
*** Sorting (Best Case, Worst Case, Memory Space)
    + Heap Sort
    + Quick Sort
    + Redix Sort
    + Merge Sort
      
*** misc
    + XML Style Sheets(XSLT)
    + Synchronized Multimedia Integration Language(SMIL)
      
** Hardware(p120)
   + XOR: not(A) * B + A * not(B) , (A + B) * not(A * B)
   + NAND to AND / OR / NOT:
     - X OR Y = (X NAND X) NAND (Y NAND Y)
     - X AND Y = (X NAND Y) NAND (X NAND Y)
       
   + Resep-Set Flip Flop (RSFF)
     + OR-NOT RSFF
       - S - (OR-NOT) - negative Y
       -       X
       - R - (OR-NOT) - Y(info bit)
         
     + NAND RSFF
       - S - NAND - X(info bit)
       -      X
       - R - NAND - Y

**** FPGA
     + keywords:
       - Hardware Description Language (e.g. VHDL, verilog)
       - system Large-scale-integration
       - SystemC
       - Application Specific Standard product(ASSP): for multiple customers
       - Application Specific Integrated Circuit(ASIC): for a specific company

         
**** LSI power management
     + keywords:
       - Multi VDD
       - Dynamic Voltage Scaling(DVS)
       - Dynamic Voltage and Frequency Scaling(DVFS)
       - *Power gating*
         
**** Data Converter
     
***** Analog to Digital (A/D) converter
      + Angular resolution(分解能)
        - 5V -> 3 bits = 5V/2^3 = (+-0.625V) per bit.
        - 5V -> 8 bits = 5V/2^8 = (+-0.0195V) per bit.
          
***** two's complement (2^n - x), -1 -> 2^n - 1 = 111 when n = 3
      + one's complement flip 0 and 1. Hence it could represent -0.
      + while two's complement has a wider range, from -2^n to 2^n - 1.
